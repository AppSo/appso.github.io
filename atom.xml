<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AppSo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-02T17:26:26.610Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>AppSo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用 Docker 部署 Shadowsocks 服务</title>
    <link href="http://yoursite.com/2019/09/03/docker/"/>
    <id>http://yoursite.com/2019/09/03/docker/</id>
    <published>2019-09-02T16:07:04.000Z</published>
    <updated>2019-09-02T17:26:26.610Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/docker.png" alt></p><a id="more"></a><p><a href="https://www.docker.com/" target="_blank" rel="noopener">Docker</a> 是一个开放源代码软件项目，让应用程序布署在软件容器下的工作可以自动化进行，借此在操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。<br>Docker 利用 Linux 核心中的资源分脱机制，例如 cgroups，以及 Linux 核心名字空间（name space），来创建独立的软件容器（containers）。这可以在单一 Linux 实体下运作，避免启动一个虚拟机造成的额外负担。<br>简单概括起来就是，Docker 是个容器，什么都能往里塞，你也可以理解为是一个轻量化的虚拟机。<br>使用 Docker 的好处就是对当前系统的环境没有破坏性，基本上一款镜像可以跑在任意包含了 Docker 的机器上，可以说是十分方便了。</p><h2 id="安装并启动-Docker"><a href="#安装并启动-Docker" class="headerlink" title="安装并启动 Docker"></a>安装并启动 Docker</h2><p>操作系统内核大于等于 3.10 的都可以安装最新版 Docker，可以直接运行官方的安装脚本一键安装。<br>执行脚本方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- get.docker.com | bash</span><br></pre></td></tr></table></figure><p>安装完成后，运行下面的命令，验证是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>允许 Docker 开机自启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h2 id="Shadowsocks-libev-Docker-Image"><a href="#Shadowsocks-libev-Docker-Image" class="headerlink" title="Shadowsocks-libev Docker Image"></a>Shadowsocks-libev Docker Image</h2><p>基于官方 debian:stretch 镜像制作，直接利用 <code>apt-get</code> 安装好 shadowsocks-libev 和 simple-obfs 即可。<br>该容器在启动时依赖于读取宿主机里的配置文件，因此在启动该镜像时配合不同的 config 文件，就能开启任意个 Docker ，也就是所谓的多端口。<br>把配置文件放在宿主机里，是基于这样的考量：随时在宿主机里修改配置的端口，密码，加密方式等信息，然后只需重启容器，无需再次创建新的容器。</p><h3 id="支持的-Tags-及-Dockerfile"><a href="#支持的-Tags-及-Dockerfile" class="headerlink" title="支持的 Tags 及 Dockerfile"></a>支持的 Tags 及 Dockerfile</h3><p>latest <a href="https://github.com/AppSo/shadowsocks_install/blob/master/docker/shadowsocks-libev/Dockerfile" target="_blank" rel="noopener">(Dockerfile)</a><br>alpine <a href="https://github.com/AppSo/shadowsocks_install/blob/master/docker/shadowsocks-libev/alpine/Dockerfile" target="_blank" rel="noopener">(Dockerfile)</a></p><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull appso/shadowsocks-libev</span><br></pre></td></tr></table></figure><p>或者拉取以 alpine 镜像制作的，其特点就是文件容量非常小</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull appso/shadowsocks-libev:alpine</span><br></pre></td></tr></table></figure><h3 id="创建-config-文件"><a href="#创建-config-文件" class="headerlink" title="创建 config 文件"></a>创建 config 文件</h3><p>比如在目录 <code>/etc/shadowsocks-libev</code> 下创建 config.json，完整路径也就是 <code>/etc/shadowsocks-libev/config.json</code><br>范例内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:9000,</span><br><span class="line">    &quot;password&quot;:&quot;password&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-gcm&quot;,</span><br><span class="line">    &quot;fast_open&quot;:false,</span><br><span class="line">    &quot;nameserver&quot;:&quot;8.8.8.8&quot;,</span><br><span class="line">    &quot;mode&quot;:&quot;tcp_and_udp&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想同时开启 simple-obfs，那么配置文件范例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_port&quot;:9000,</span><br><span class="line">    &quot;password&quot;:&quot;password&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-gcm&quot;,</span><br><span class="line">    &quot;fast_open&quot;:false,</span><br><span class="line">    &quot;nameserver&quot;:&quot;8.8.8.8&quot;,</span><br><span class="line">    &quot;mode&quot;:&quot;tcp_and_udp&quot;,</span><br><span class="line">    &quot;plugin&quot;:&quot;obfs-server&quot;,</span><br><span class="line">    &quot;plugin_opts&quot;:&quot;obfs=http&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件里面所有选项的含义，可以参考<a href="https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/shadowsocks-libev.asciidoc" target="_blank" rel="noopener">这个链接</a>。</p><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>在上面这个范例里，定义的端口是 9000，那么在启动容器时就需要将 9000 端口映射到宿主机的对外端口上。<br>启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 -p 9000:9000/udp --name ss-libev -v /etc/shadowsocks-libev:/etc/shadowsocks-libev appso/shadowsocks-libev</span><br></pre></td></tr></table></figure><p><code>docker run</code>：开始运行一个容器。<br><code>-d</code> 参数：容器以后台运行并输出容器 ID。<br><code>-p</code> 参数：容器的 9000 端口映射到本机的 9000 端口。默认是映射 TCP，当需要映射 UDP 时，那就再追加一次 UDP 的映射。冒号前面是宿主机端口，冒号后面是容器端口，可以写成一致，也可以不一致。<br><code>–name</code> 参数：给容器分配一个识别符，方便将来的启动，停止，删除等操作。<br><code>-v</code> 参数：挂载卷（volume），冒号前面是宿主机的路径，冒号后面是容器的路径，可以写成一致，也可以不一致。<br><code>appso/shadowsocks-libev</code>：这是拉取回来的镜像路径。</p><p>当然，这里也可以启动 Tag 为 alpine 的镜像命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 -p 9000:9000/udp --name ss-libev -v /etc/shadowsocks-libev:/etc/shadowsocks-libev appso/shadowsocks-libev:alpine</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：此处仅作为演示，不能同时执行上面的这两个启动命令，因为端口都是 9000，产生冲突了。推荐选 Tag 为 alpine 的镜像的，因为文件的体积会相对比较小。</p><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><p>利用如下命令可以查看所有已创建的 Docker 容器并显示容器的大小等信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -as</span><br></pre></td></tr></table></figure><h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><p>利用如下命令可以停止正在运行中的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop <span class="variable">$name</span></span><br></pre></td></tr></table></figure><p>此处的 <code>$name</code> 就是在启动容器那一步定义的容器的识别符，比如范例的 ss-libev</p><h3 id="启动容器-1"><a href="#启动容器-1" class="headerlink" title="启动容器"></a>启动容器</h3><p>利用如下命令可以启动已经停止的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start <span class="variable">$name</span></span><br></pre></td></tr></table></figure><h2 id="ShadowsocksR-Docker-Image"><a href="#ShadowsocksR-Docker-Image" class="headerlink" title="ShadowsocksR Docker Image"></a>ShadowsocksR Docker Image</h2><p>基于官方 debian:stretch 镜像制作，安装的是 Github 上目前<a href="https://github.com/AppSo/shadowsocksr" target="_blank" rel="noopener">最新的版本</a>。该容器在启动时依赖于读取宿主机里的配置文件，因此在启动该镜像时配合不同的 config 文件，就能开启任意个 Docker ，也就是所谓的多端口。<br>把配置文件放在宿主机里，是基于这样的考量：随时在宿主机里修改配置的端口，密码，加密方式等信息，然后只需重启容器，无需再次创建新的容器。</p><h3 id="支持的-Tags-及-Dockerfile-1"><a href="#支持的-Tags-及-Dockerfile-1" class="headerlink" title="支持的 Tags 及 Dockerfile"></a>支持的 Tags 及 Dockerfile</h3><p>latest <a href="https://github.com/AppSo/shadowsocks_install/blob/master/docker/shadowsocksr/Dockerfile" target="_blank" rel="noopener">(Dockerfile)</a><br>alpine <a href="https://github.com/AppSo/shadowsocks_install/blob/master/docker/shadowsocksr/alpine/Dockerfile" target="_blank" rel="noopener">(Dockerfile)</a></p><h3 id="拉取镜像-1"><a href="#拉取镜像-1" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull appso/shadowsocksr</span><br></pre></td></tr></table></figure><p>或者拉取基于 python:3.6-alpine 镜像制作的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull appso/shadowsocksr:alpine</span><br></pre></td></tr></table></figure><h3 id="创建-config-文件-1"><a href="#创建-config-文件-1" class="headerlink" title="创建 config 文件"></a>创建 config 文件</h3><p>比如在目录 <code>/etc/shadowsocksr</code> 下创建 config.json，完整路径也就是 <code>/etc/shadowsocksr/config.json</code><br>范例内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;server_ipv6&quot;:&quot;::&quot;,</span><br><span class="line">    &quot;server_port&quot;:9000,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;password&quot;,</span><br><span class="line">    &quot;timeout&quot;:120,</span><br><span class="line">    &quot;method&quot;:&quot;none&quot;,</span><br><span class="line">    &quot;protocol&quot;:&quot;auth_chain_b&quot;,</span><br><span class="line">    &quot;protocol_param&quot;:&quot;&quot;,</span><br><span class="line">    &quot;obfs&quot;:&quot;http_simple&quot;,</span><br><span class="line">    &quot;obfs_param&quot;:&quot;&quot;,</span><br><span class="line">    &quot;redirect&quot;:&quot;&quot;,</span><br><span class="line">    &quot;dns_ipv6&quot;:false,</span><br><span class="line">    &quot;fast_open&quot;:false,</span><br><span class="line">    &quot;workers&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ShadowsocksR 协议插件文档的含义，可以参考<a href="https://github.com/AppSo/shadowsocks-rss/blob/master/ssr.md" target="_blank" rel="noopener">这个链接</a>。</p><h3 id="启动容器-2"><a href="#启动容器-2" class="headerlink" title="启动容器"></a>启动容器</h3><p>在上面这个范例里，定义的端口是 9000，那么在启动容器时就需要将 9000 端口映射到宿主机的对外端口上。<br>启动命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 -p 9000:9000/udp --name ssr -v /etc/shadowsocksr:/etc/shadowsocksr appso/shadowsocksr</span><br></pre></td></tr></table></figure><p>启动 Tag 为 alpine 的镜像命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 9000:9000 -p 9000:9000/udp --name ssr -v /etc/shadowsocksr:/etc/shadowsocksr appso/shadowsocksr:alpine</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：此处仅作为演示，不能同时执行上面的这两个启动命令，因为端口都是 9000，产生冲突了。推荐选 Tag 为 alpine 的镜像的，因为文件的体积会相对比较小。</p><p><em>参考链接</em></p><p><em><a href="https://hub.docker.com/r/appso/shadowsocks-libev/" target="_blank" rel="noopener">https://hub.docker.com/r/appso/shadowsocks-libev/</a></em><br><em><a href="https://hub.docker.com/r/appso/shadowsocksr/" target="_blank" rel="noopener">https://hub.docker.com/r/appso/shadowsocksr/</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/docker.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shadowsocks 一键安装脚本（四合一）</title>
    <link href="http://yoursite.com/2018/11/21/Shadowsocks-install/"/>
    <id>http://yoursite.com/2018/11/21/Shadowsocks-install/</id>
    <published>2018-11-20T16:44:28.000Z</published>
    <updated>2019-08-27T09:19:30.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/shadowsocks.png" alt></p><blockquote><p>本脚本适用环境</p></blockquote><p>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+<br>内存要求：≥128M<br>更新日期：2019 年 01 月 11 日</p><a id="more"></a><h3 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h3><p>1、一键安装 Shadowsocks-Python， ShadowsocksR(SSR)， Shadowsocks-Go， Shadowsocks-libev 版（四选一）服务端；<br>2、各版本的启动脚本及配置文件名不再重合；<br>3、每次运行可安装一种版本；<br>4、支持以多次运行来安装多个版本，且各个版本可以共存（注意端口号需设成不同）；<br>5、若已安装多个版本，则卸载时也需多次运行（每次卸载一种）；</p><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>服务器端口：自己设定（如不设定，默认从 9000-19999 之间随机生成）<br>密码：自己设定（如不设定，默认为 teddysun.com）<br>加密方式：自己设定（如不设定，Python 和 libev 版默认为 aes-256-gcm，R 和 Go 版默认为 aes-256-cfb）<br>协议（protocol）：自己设定（如不设定，默认为 origin）（仅限 ShadowsocksR 版）<br>混淆（obfs）：自己设定（如不设定，默认为 plain）（仅限 ShadowsocksR 版）<br><strong>备注</strong>：脚本默认创建单用户配置文件，如需配置多用户，请手动修改相应的配置文件后重启即可。</p><h3 id="客户端下载"><a href="#客户端下载" class="headerlink" title="客户端下载"></a>客户端下载</h3><p>常规版 Windows 客户端<br><a href="https://github.com/shadowsocks/shadowsocks-windows/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-windows/releases</a></p><p>ShadowsocksR 版 Windows 客户端<br><a href="https://github.com/AppSo/shadowsocks-rss/releases" target="_blank" rel="noopener">https://github.com/AppSo/shadowsocks-rss/releases</a></p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用root用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/ss-all)</span><br></pre></td></tr></table></figure><h3 id="安装完成后，脚本提示如下"><a href="#安装完成后，脚本提示如下" class="headerlink" title="安装完成后，脚本提示如下"></a>安装完成后，脚本提示如下</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Congratulations, your_shadowsocks_version install completed!</span><br><span class="line">Your Server IP        :your_server_ip</span><br><span class="line">Your Server Port      :your_server_port</span><br><span class="line">Your Password         :your_password</span><br><span class="line">Your Encryption Method:your_encryption_method</span><br><span class="line"></span><br><span class="line">Your QR Code: (For Shadowsocks Windows, OSX, Android and iOS clients)</span><br><span class="line"> ss://your_encryption_method:your_password@your_server_ip:your_server_port</span><br><span class="line">Your QR Code has been saved as a PNG file path:</span><br><span class="line"> your_path.png</span><br><span class="line"></span><br><span class="line">Welcome to visit:https://teddysun.com/486.html</span><br><span class="line">Enjoy it!</span><br></pre></td></tr></table></figure><h3 id="卸载方法"><a href="#卸载方法" class="headerlink" title="卸载方法"></a>卸载方法</h3><p>若已安装多个版本，则卸载时也需多次运行（每次卸载一种）</p><p>使用root用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./shadowsocks-all.sh uninstall</span><br></pre></td></tr></table></figure><h3 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h3><p>启动脚本后面的参数含义，从左至右依次为：启动，停止，重启，查看状态。</p><p>Shadowsocks-Python 版：<br>/etc/init.d/shadowsocks-python start | stop | restart | status</p><p>ShadowsocksR 版：<br>/etc/init.d/shadowsocks-r start | stop | restart | status</p><p>Shadowsocks-Go 版：<br>/etc/init.d/shadowsocks-go start | stop | restart | status</p><p>Shadowsocks-libev 版：<br>/etc/init.d/shadowsocks-libev start | stop | restart | status</p><h3 id="各版本默认配置文件"><a href="#各版本默认配置文件" class="headerlink" title="各版本默认配置文件"></a>各版本默认配置文件</h3><p>Shadowsocks-Python 版：<br>/etc/shadowsocks-python/config.json</p><p>ShadowsocksR 版：<br>/etc/shadowsocks-r/config.json</p><p>Shadowsocks-Go 版：<br>/etc/shadowsocks-go/config.json</p><p>Shadowsocks-libev 版：<br>/etc/shadowsocks-libev/config.json</p><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><p>安装时可选 16 种加密方式的其中之一（Python 和 libev 版）。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">aes-256-gcm</span><br><span class="line">aes-192-gcm</span><br><span class="line">aes-128-gcm</span><br><span class="line">aes-256-ctr</span><br><span class="line">aes-192-ctr</span><br><span class="line">aes-128-ctr</span><br><span class="line">aes-256-cfb</span><br><span class="line">aes-192-cfb</span><br><span class="line">aes-128-cfb</span><br><span class="line">camellia-128-cfb</span><br><span class="line">camellia-192-cfb</span><br><span class="line">camellia-256-cfb</span><br><span class="line">chacha20-ietf-poly1305</span><br><span class="line">chacha20-ietf</span><br><span class="line">chacha20</span><br><span class="line">rc4-md5</span><br></pre></td></tr></table></figure><p>安装时可选 9 种加密方式的其中之一（Go 版）。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aes-256-cfb</span><br><span class="line">aes-192-cfb</span><br><span class="line">aes-128-cfb</span><br><span class="line">aes-256-ctr</span><br><span class="line">aes-192-ctr</span><br><span class="line">aes-128-ctr</span><br><span class="line">chacha20-ietf</span><br><span class="line">chacha20</span><br><span class="line">rc4-md5</span><br></pre></td></tr></table></figure><p>安装时可选 16 种加密方式的其中之一（none 是不加密，ShadowsocksR 版）。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">none</span><br><span class="line">aes-256-cfb</span><br><span class="line">aes-192-cfb</span><br><span class="line">aes-128-cfb</span><br><span class="line">aes-256-cfb8</span><br><span class="line">aes-192-cfb8</span><br><span class="line">aes-128-cfb8</span><br><span class="line">aes-256-ctr</span><br><span class="line">aes-192-ctr</span><br><span class="line">aes-128-ctr</span><br><span class="line">chacha20-ietf</span><br><span class="line">chacha20</span><br><span class="line">salsa20</span><br><span class="line">xchacha20</span><br><span class="line">xsalsa20</span><br><span class="line">rc4-md5</span><br></pre></td></tr></table></figure><p>安装时可选 12 种协议（protocol）的其中之一（仅限 ShadowsocksR 版）。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">origin</span><br><span class="line">verify_deflate</span><br><span class="line">auth_sha1_v4</span><br><span class="line">auth_sha1_v4_compatible</span><br><span class="line">auth_aes128_md5</span><br><span class="line">auth_aes128_sha1</span><br><span class="line">auth_chain_a</span><br><span class="line">auth_chain_b</span><br><span class="line">auth_chain_c</span><br><span class="line">auth_chain_d</span><br><span class="line">auth_chain_e</span><br><span class="line">auth_chain_f</span><br></pre></td></tr></table></figure><p>安装时可选 9 种混淆（obfs）的其中之一（仅限 ShadowsocksR 版）。如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plain</span><br><span class="line">http_simple</span><br><span class="line">http_simple_compatible</span><br><span class="line">http_post</span><br><span class="line">http_post_compatible</span><br><span class="line">tls1.2_ticket_auth</span><br><span class="line">tls1.2_ticket_auth_compatible</span><br><span class="line">tls1.2_ticket_fastauth</span><br><span class="line">tls1.2_ticket_fastauth_compatible</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/shadowsocks.png&quot; alt&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本脚本适用环境&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;系统支持：CentOS 6+，Debian 7+，Ubuntu 12+&lt;br&gt;内存要求：≥128M&lt;br&gt;更新日期：2019 年 01 月 11 日&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单介绍一下网络连接的封锁与反封锁</title>
    <link href="http://yoursite.com/2017/11/20/anti-block/"/>
    <id>http://yoursite.com/2017/11/20/anti-block/</id>
    <published>2017-11-20T12:35:48.000Z</published>
    <updated>2017-11-20T13:02:51.114Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间，针对网络连接的战争愈演愈烈，双方都在尝试不同的策略。以至于对于新人来说，很难理解哪些已经发生过，哪些还在尝试中。于是我打算写篇文章来简单介绍一下整个故事的来龙去脉。</p><p><img src="/images/anti-block.png" alt></p><a id="more"></a><h2 id="史前时代"><a href="#史前时代" class="headerlink" title="史前时代"></a>史前时代</h2><p>最早的封锁大约是 DNS 投毒和 IP 黑名单。具体细节这里不表，简单来说就是 1) 对于特定域名比如 google.com，你的浏览器解析不到正确的 IP 地址； 2) 即使碰巧解析到了正确的 IP 地址，由于 Google 在亚洲地区的 IP 地址就那么几个，发往这几个 IP 地址的数据包被全部丢弃（或 TCP Reset），也就导致了用户死活访问不到 google.com。</p><h2 id="攻防战-1-0"><a href="#攻防战-1-0" class="headerlink" title="攻防战 1.0"></a>攻防战 1.0</h2><p>由于被封的 IP 依然是少数，而 Google 在全球的 IP 数量庞大，于是网友们很快想到了解决方案，就是使用 hosts 文件指定 IP 地址。虽然亚洲地区的 IP 被封了，但美国、欧洲甚至是南美洲依然有可以访问的地址，速度慢是慢了点，但总比上不去的好。于是 hosts 文件这个方案流行了那么一段时间。</p><p>后来封锁升级了，不是针对 IP 地址的了，而是针对每一个网络连接。受限于为数不多的几个出入境节点，网民的每一个出境网络连接实际上都被扫描过一遍。于是网络协议最初设计时，并未考虑封锁这回事，无论是 HTTP 还是 HTTPS，只需要扫描每个连接的前几十个字节，就可以得到其目标地址（域名）。HTTP 是通过其 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host" target="_blank" rel="noopener">Host 头</a>，而 HTTPS 是通过 <a href="https://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank" rel="noopener">SNI</a>。</p><p>至此，针对域名，没有封不掉的，只有不想封的。</p><p>在直线连接几乎不可能的之后，那就只能绕路了，也就是代理。代理的主要三种模式是 Socks、HTTP 和 VPN。三种模式各有利弊：</p><ul><li>Socks 可以代理 TCP 和 UDP 连接，但其数据包是明文的，依然逃不过上述检测；</li><li>HTTP 可以有 TLS 加持，但只能代理 TCP 连接，对 UDP 无效；</li><li>VPN 可以代理包含 TCP / UDP 在内的各种连接，但 VPN 会转发几乎所有的数据，在可以访问 Google 的同时，可能就不能访问优酷了（地区限制）。</li></ul><p>然后 Shadowsocks 横空出世。</p><p>Shadowsocks 本质上是 Socks 的加密版本，可选择多种加密方式。一旦加了密，其传输的数据就无法被第三方检测了。并且 Shadowsocks 在转发数据之前，可以对其目的地进行判断，比如可以只转发去往 Google 的流量，而优酷的流量依然直连。在经常一段时间的优化之后，Shadowsocks 可以达到一个全局较快的连接速度，比上述的几个代理方式都要好。</p><p>由于 Shadowsocks 太过火爆，其作者被公安机关约谈，勒令不得继续参于相关项目的开发。</p><h2 id="攻防战-2-0"><a href="#攻防战-2-0" class="headerlink" title="攻防战 2.0"></a>攻防战 2.0</h2><p>中国那么多人，要把相关人员一一找出来喝茶，也不是一件容易的事。封锁这事，还得从网络连接着手。</p><p>对于一台国内的机器往一个国外的服务器发送数据的网络连接，有两种检测方式，被动式和主动式。</p><p>被动式是指检测方只观察连接中传输的内容，当内容符合某种模式（比如关键字）的时候，就把连接中断，或者服务器 IP 列入黑名单。上述的所有封锁方式均为被动式。</p><p>而主动式指的是，当观察到一个不可识别的连接时，检测方主动发起一个去往服务器的连接，通过一些编造的数据，探测出服务器是不是一台代理服务器。</p><p>Shadowsocks 协议曾被指出一个<a href="https://breakwa11.blogspot.ch/2016/09/shadowsocks.html" target="_blank" rel="noopener">严重的安全性问题</a>。只需要不到 16 次主动探测，就可以 100% 断定服务器是否在运行 Shadowsocks。具体来说，初版 Shadowsocks 协议依赖于连接头部的某一个字节来读取目标地址，这个字节的取值只有三种。当这个字节的取值不合法时，Shadowsocks 会快速中断连接，否则继续读取剩下的内容。于是这一特征可被用于探测一个服务器是否为 Shadowsocks 代理。</p><p>为了应对这一探测方式，Shadowsocks 对其加密方式升级了两次（OTA 和 AEAD）。目前看来这一漏洞，以及其它可能的主动探测方式，都被避免了。</p><p>同时期还有多个流行的翻墙工具，其原理和 Shadowsocks 大同小异，这里略过。</p><h2 id="番外篇-1-0"><a href="#番外篇-1-0" class="headerlink" title="番外篇 1.0"></a>番外篇 1.0</h2><p>既然代理工具有漏洞，那么检测工具也一会有漏洞。只要发现并利用这些漏洞，一样可以突破封锁。</p><p>曾经有一个项目“西厢计划”，就是利用了检测工具的漏洞，伪造了一些数据包，使它在检测方看上去上一个网络连接，但在目的服务器看来又是另一回事。检测方以为自己已经封锁了该连接，但实际上并没有。</p><p>和 Shadowsocks 的升级一样，检测方的算法也一样可以升级。升级之后，西厢计划便失效了。</p><h2 id="攻防战-3-0"><a href="#攻防战-3-0" class="headerlink" title="攻防战 3.0"></a>攻防战 3.0</h2><p>从信息学的角度来说，Shadowsocks 协议是一个近乎完美的协议。它的数据完全随机，无法 100% 确定这个网络连接是否为 Shadowsocks。但从另一方面来说，网络数据并不是均匀分布的，保守来说，HTTP 和 HTTPS 流量占据了 70% 以上。而如果一个服务器接收的流量 90% 是杂乱无章的，那么它就很可疑了。虽然检测方不能严格证明那就是 Shadowsocks，但秀才遇到兵啊……</p><p>既然随机数据可疑，那我们就把数据伪装成 HTTP 或者 HTTPS 好了。由于 HTTPS 是大势所趋，并且 HTTPS 传输的内容天生不可能被破解，把代理数据伪装成 HTTPS 也是一个比较合理的选择。</p><p>由于检测方无法判断一个 HTTPS 连接是正常的网站流量，还是代理。如果封锁所有的 HTTPS 流量，那无疑是一个杀敌五百，自损一千的昏招。当然急病乱投医也是有可能的……</p><h2 id="第二战场-1-0"><a href="#第二战场-1-0" class="headerlink" title="第二战场 1.0"></a>第二战场 1.0</h2><p>所有的代理工具都不是系统自带的，用户使用代理工具之前，需要先下载和安装。于是封锁下载途径也是一种封锁。Apple 就按要求移除了所有 VPN 应用。此战场防御方完败。</p><p><strong>目前明面上的攻防到此为止，接下来说说一些想法和揣测</strong></p><h2 id="攻防战-4-0"><a href="#攻防战-4-0" class="headerlink" title="攻防战 4.0"></a>攻防战 4.0</h2><p>虽然流量经过了加密，但加密的只是内容，不能排除还有其它的特征。比如 TLS (HTTPS 所用的加密协议）的握手环节，客户端和服务器互相发送的数据是有规律的。比如握手三次，每一次的数据量大致是固定的。如果有一个连接，也有三次握手，每一次的数据量和 TLS 相当，但是内容是混乱的，那么这个连接是不是 Shadowsocks 连接呢？当然 Shadowsocks 有一些额外的数据，这个另说。</p><p>目前翻墙圈在这一问题上有很大的争论。对于检测方是否足够强的技术做类似的检测，以及是否有足够的把握只封代理都存在疑惑。但毫无疑问，这将是下一个值得研究的领域。</p><p>另一个热点是分布式或者P2P。</p><p>这一领域已经被 Tor 证明为成功或者失败了（取决于你怎么看待 Tor）。我个人不喜欢 Tor 因为它速度太慢。虽然 P2P 这一术语最近很热，听上去也很有希望，但实际上它并不适用于翻墙。翻墙的过程需要【墙内的P】2【墙外的P】，并不是任意两个 P 都可以自由组合的。</p><p>目前对翻墙 P2P 的研究和应用都比较少，前景不明朗，观望中。</p><p>以上是对翻墙历史的简单总结，希望对新人有帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间，针对网络连接的战争愈演愈烈，双方都在尝试不同的策略。以至于对于新人来说，很难理解哪些已经发生过，哪些还在尝试中。于是我打算写篇文章来简单介绍一下整个故事的来龙去脉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/anti-block.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>为何 shadowsocks 要弃用一次性验证 (OTA)</title>
    <link href="http://yoursite.com/2017/09/26/why-do-shadowsocks-deprecate-ota/"/>
    <id>http://yoursite.com/2017/09/26/why-do-shadowsocks-deprecate-ota/</id>
    <published>2017-09-26T15:44:25.000Z</published>
    <updated>2017-09-26T16:57:02.403Z</updated>
    
    <content type="html"><![CDATA[<p>前些天，shadowsocks 提出了 SIP004 草案，旨在使用 <code>AEAD 算法</code> 取代原先的不安全的 <code>流加密 + OTA</code>，并弃用了一次性验证 (OTA)。</p><p>新协议的提出对于 shadowsocks 是一个非常非常重大的改进，因此我写了这篇博文为看不懂洋文的朋友们科普一下「为什么 OTA 会被这么快被弃用」以及「为什么应该使用新协议」。</p><a id="more"></a><h2 id="OTA-是什么"><a href="#OTA-是什么" class="headerlink" title="OTA 是什么"></a>OTA 是什么</h2><p>OTA（One Time Auth，<a href="https://shadowsocks.org/en/spec/one-time-auth.html" target="_blank" rel="noopener">一次性验证</a>），是之前 shadowsocks 为了增强安全性，抵抗 CCA（Chosen-ciphertext Attack，<a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E5%AF%86%E6%96%87%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">选择密文攻击</a>）而加入的实验性功能。</p><p>我觉得应该很多人都听过这玩意 —— 就算不知道 OTA 是啥好歹也在 shadowsocks 各分支的客户端上看到过「一次性验证」的开关吧？虽然这个名字确实起得有点让人不明所以就是了（笑）。</p><p>那么下面我来科普下当初为什么要加入 OTA 功能。</p><h2 id="原协议的弱点"><a href="#原协议的弱点" class="headerlink" title="原协议的弱点"></a>原协议的弱点</h2><p>原 shadowsocks 协议的这个漏洞其实早在 2015 年就被 <a href="https://github.com/breakwa11" target="_blank" rel="noopener">@breakwa11</a> 提出了。当时正值 @clowwindy <a href="https://blessing.studio/about-clowwindy-archive/" target="_blank" rel="noopener">被喝茶</a>之际，此 issue 下闹得沸沸扬扬撕逼不断，过了好一段时间后才开始有正经的技术讨论。</p><p>如果你想要了解一下当时的情况可以去看看 <a href="https://github.com/breakwa11/shadowsocks-rss/issues/38" target="_blank" rel="noopener">这个 issue</a>，我这里简略概括一下当时提出的漏洞。</p><h3 id="shadowsocks-协议"><a href="#shadowsocks-协议" class="headerlink" title="shadowsocks 协议"></a>shadowsocks 协议</h3><p><a href="https://shadowsocks.org/en/spec/protocol.html" target="_blank" rel="noopener">原 shadowsocks</a> 协议 的 TCP 握手包（加密后）的格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------+----------+</span><br><span class="line">|  IV   | Payload  |</span><br><span class="line">+-------+----------+</span><br><span class="line">| Fixed | Variable |</span><br><span class="line">+-------+----------+</span><br></pre></td></tr></table></figure><p>其中的 IV（Initialization Vector, <a href="https://zh.wikipedia.org/wiki/%E5%88%9D%E5%A7%8B%E5%90%91%E9%87%8F" target="_blank" rel="noopener">初始化向量</a>）是使用随机数生成器生成的一个固定长度的输入值。通过引入 <code>IV</code> 能够使相同的明文和相同的密钥产生不同的密文，让攻击者难以对同一把密钥的密文进行破解。</p><p>shadowsocks 服务端会用这个 <code>IV</code> 和 <code>pre-shared key</code>（预共享密钥，通常是用户设置的密码）来解密 TCP 数据包中的 <code>payload</code>。</p><p>解密后的内容格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+--------------+---------------------+------------------+----------+</span><br><span class="line">| Address Type | Destination Address | Destination Port |   Data   |</span><br><span class="line">+--------------+---------------------+------------------+----------+</span><br><span class="line">|      1       |       Variable      |         2        | Variable |</span><br><span class="line">+--------------+---------------------+------------------+----------+</span><br></pre></td></tr></table></figure><p>其中 <code>Address Type</code> (ATYP) 是地址类型，占一个字节，有三个可能的取值：<code>01</code>, <code>03</code>, <code>04</code>，分别对应 <code>IPv4</code>, <code>hostname</code>, <code>IPv6</code> 类型的地址。这些都是 <a href="https://www.ietf.org/rfc/rfc1928.txt" target="_blank" rel="noopener">RFC1928</a> 中定义的标准，有兴趣可以去看看。</p><p>握手完成后 shadowsocks 中继就会工作在流模式下，后续的所有 TCP 数据包不会再带上 <code>IV</code>，而是使用握手时协商的那个 <code>IV</code>。</p><p>说完了原 shadowsocks 协议的内容，下面说说该协议的不足之处。</p><h3 id="原协议的缺陷"><a href="#原协议的缺陷" class="headerlink" title="原协议的缺陷"></a>原协议的缺陷</h3><p>正如上表所示，原始 shadowsocks 协议 TCP 握手包中的 <code>IV</code> 字段是 Fixed（定长）的。不同的加密算法 <code>IV</code> 长度不同，对于 <code>rc4-md5</code> 和 <code>aes</code> 系列等常用算法，这个长度是 <code>16</code> 字节。各加密算法的详细信息可以在 <a href="https://shadowsocks.org/en/spec/cipher.html" target="_blank" rel="noopener">官方文档 - Cipher</a> 查看。</p><p>而服务端为了判断数据是否有效，会检查数据包中表示地址信息的那个字节，看它是不是上面提到的三个可能取值。<strong>如果是，就尝试解析后面的地址和端口进行连接；如果不是，立即断开连接</strong>。</p><p>正是 shadowsocks 服务器的这个行为使得主动探测成为可能。</p><h4 id="主动探测的原理"><a href="#主动探测的原理" class="headerlink" title="主动探测的原理"></a>主动探测的原理</h4><blockquote><p>该方法由 @breakwa11 <a href="https://github.com/breakwa11/shadowsocks-rss/issues/50" target="_blank" rel="noopener">提供</a></p></blockquote><p>一般来讲，「表示地址类型的那个字节」是被加密后发送的，所以第三方无法精确的修改它。<strong>但是不巧的是</strong>，shadowsocks 所有的加密方式都是 <code>stream cipher</code>（<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">流加密</a>），而这种加密方式的特点就是<strong>「明文数据流与密钥数据流一一对应」</strong>。</p><p>通俗地讲，即对应修改了某个位置的密文（根据加密模式的不同，可能影响到后面其他密文块的解密，也可能影响不到，但在这里这个性质并不重要），如果预先知道了明文的模式，虽然无法解密还原出内容，但可以修改密文中的特定字节，起到修改<strong>解密后的明文</strong>的效果。</p><p>根据流加密的这个特性，坏东西们就可以通过伪造 TCP 数据包来主动探测 shadowsocks 服务器了。攻击者只要暴力尝试修改加密后的数据包中 <code>IV</code> 之后紧接着的那个字节（如果使用的加密算法 <code>IV</code> 长度为 16 字节，那么就修改第 17 个字节），穷举 <code>2^8 = 256</code> 种可能性，<strong>如果被测试的服务器有一种到三种情况下没有立即关闭连接</strong>，就可以判断出这台机子的这个端口开放的是 shadowsocks 服务。</p><p>或许这种主动探测方法正在被 GFW 大规模应用，谁知道呢？你正在使用的原版 shadowsocks 代理随时有可能被封锁。</p><h4 id="防范主动探测"><a href="#防范主动探测" class="headerlink" title="防范主动探测"></a>防范主动探测</h4><p>经过讨论后上述漏洞被证明是 <a href="https://github.com/breakwa11/shadowsocks-rss/issues/38#issuecomment-136022971" target="_blank" rel="noopener">确实存在</a> 的，所以现在大部分的 shadowsocks 分支都已经加入了针对这种探测方法的对抗措施（e.g. <a href="https://github.com/shadowsocks/shadowsocks-libev/compare/v2.5.4...v2.5.5" target="_blank" rel="noopener">shadowsocks-libev v2.5.5+</a>），即「随机超时抵抗」而不是立即断开连接，配合自动黑名单等机制可以有效减少被探测到的风险。</p><p>但是这种方法总归不是长久之计，要怎么办呢？ </p><h2 id="OTA-闪亮登场"><a href="#OTA-闪亮登场" class="headerlink" title="OTA 闪亮登场"></a>OTA 闪亮登场</h2><p>上述情况下主动探测能够得逞的原因是<strong>服务器没有对收到的数据包进行校验</strong>，随便哪个阿猫阿狗发来的数据包，不管有没有被恶意篡改过，原来的 shadowsocks 服务器都会做出同样的反应。</p><p>这时 <a href="https://github.com/madeye" target="_blank" rel="noopener">@madeye</a>（现在的 shadowsocks 维护者）提出了 One Time Auth 即「一次性验证」的提案，给原 shadowsocks 协议加上了数据包验证。</p><h3 id="OTA-协议"><a href="#OTA-协议" class="headerlink" title="OTA 协议"></a>OTA 协议</h3><p>开启了 OTA 后的 shadowsocks 握手包（加密前）是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------+---------------------+------------------+-----------+</span><br><span class="line">| ATYP | Destination Address | Destination Port | HMAC-SHA1 |</span><br><span class="line">+------+---------------------+------------------+-----------+</span><br><span class="line">|  1   |       Variable      |         2        |    10     |</span><br><span class="line">+------+---------------------+------------------+-----------+</span><br></pre></td></tr></table></figure><p>可以看到它添加了一个 <code>HMAC-SHA1</code> 字段，这个字段是将除了 <code>DATA</code> 通过 <code>HMAC-SHA1</code> 算法（以 <code>IV</code> + <code>PSK</code> 作为 key）生成的。并且数据包头部的 ATYP 添加了一个标志位用于指示 OTA 是否开启（<code>ATYP &amp; 0x10 == 0x10</code>）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+----------+-----------+----------+----</span><br><span class="line">| DATA.LEN | HMAC-SHA1 |   DATA   | ...</span><br><span class="line">+----------+-----------+----------+----</span><br><span class="line">|     2    |     10    | Variable | ...</span><br><span class="line">+----------+-----------+----------+----</span><br></pre></td></tr></table></figure><p>握手完成后，接下来的 TCP 数据包均在原始协议的包上添加了 <code>DATA.LEN</code>（包长度）和 <code>HMAC-SHA1</code> 字段。这样，服务器就可以对数据包进行完整性校验，也就可以识别出被篡改过的数据包了。</p><h3 id="OTA-的缺陷"><a href="#OTA-的缺陷" class="headerlink" title="OTA 的缺陷"></a>OTA 的缺陷</h3><p>OTA 增强了安全性，可以防范 CCA，也解决了原版协议数据包容易被篡改的问题，听起来很美好，不是吗？</p><p><strong>但是</strong>，对于这个协议的实现，shadowsocks-libev 及其它大部分分支均假定第一个数据包必须包含整个带了 <code>SHA1-MAC</code> 的头部，否则断开连接。</p><p>OK，又一个可以通过服务器行为进行主动探测的地方。不过这种主动探测也可以通过上面提到的「随机超时抵抗」来进行防范，真正可怕的在下面：</p><blockquote><p>该方法由 @breakwa11 提供</p></blockquote><p>还记得我们上面提到的 <code>stream cipher</code>（流加密）的特点吗？攻击者可是使用同样的套路修改数据包中的 <code>DATA.LEN</code> 字段，然后通过观察服务器的反应来判断这是否是一个 shadowsocks 服务器。</p><p>举个栗子，如果攻击者恶意构造 <code>DATA.LEN</code> 的高位字节密文，使得解密后 <code>DATA.LEN</code> 的数值变得特别大（但是后面的 <code>DATA</code> 的大小并没有改变），shadowsocks 服务器就会继续等待那些实际上<strong>并不存在</strong>的数据传输完成直到超时。因此只要在发送恶意数据包后观察服务器是不是「不会断开连接且至少等待 1 分钟无任何数据包」即可确定该服务器是否开启了 shadowsocks 服务。</p><p>没错，这样的检测方法比检测原版协议还要神不知鬼不觉，甚至不会在服务端留下任何可疑的痕迹。OTA 当初是为了给原版协议的流加密加上一个认证以增强安全性，殊不知这带来了更大的隐患，这也是为什么 shadowsocks-org 要急急忙忙弃用 OTA 的原因。</p><h2 id="新协议-AEAD"><a href="#新协议-AEAD" class="headerlink" title="新协议 AEAD"></a>新协议 AEAD</h2><h3 id="之前协议的缺陷汇总分析"><a href="#之前协议的缺陷汇总分析" class="headerlink" title="之前协议的缺陷汇总分析"></a>之前协议的缺陷汇总分析</h3><p>原版 shadowsocks 协议最大的缺陷就是未对数据包完整性进行校验，再加上流加密的特点，导致了攻击者可以通过穷举的方式修改密文进行基于服务器行为的主动探测。</p><p>OTA 协议虽然通过在数据包尾部附上 <code>HMAC-SHA1</code> 字段对 <code>DATA</code> 的完整性进行了验证，但是包首部的 <code>DATA.LEN</code> 用于计算偏移的指示 <code>DATA</code> 长度的字段并没有经过验证。这导致了攻击者可以通过构建高位的 <code>DATA.LEN</code> 密文进行更隐蔽的主动探测。</p><p>因此，在这次新协议草案的讨论过程中<a href="https://github.com/shadowsocks/shadowsocks-org/issues/30#issue-200289203" target="_blank" rel="noopener">参照了</a> shadowsocksR 协议的一个重要改进 —— 对 <code>DATA.LEN</code> 进行单独校验，参见：<a href="https://github.com/breakwa11/shadowsocks-rss/blob/master/ssr.md" target="_blank" rel="noopener">ShadowsocksR 协议插件文档</a>。</p><h3 id="AEAD-是啥"><a href="#AEAD-是啥" class="headerlink" title="AEAD 是啥"></a>AEAD 是啥</h3><p>在通常的密码学应用中，Confidentiality（保密）用加密实现，消息认证用 MAC（Message Authentication Code，消息验证码）实现。这两种算法的配合方式，引发了很多安全漏洞，过去曾经有 3 种方法：</p><ol><li><p>Encrypt-and-MAC (E&amp;M)</p></li><li><p>MAC-then-Encrypt (MtE) &lt;- 即 OTA 的做法</p></li><li><p>Encrypt-then-MAC (EtM) &lt;- 新协议的做法</p></li></ol><p>然而后来人们发现，<code>E&amp;M</code> 和 <code>MtE</code> 都是有安全问题的，所以 2008 年起， 逐渐提出了「用一个算法在内部同时实现加密和认证」的 idea，称为 <a href="https://en.wikipedia.org/wiki/Authenticated_encryption" target="_blank" rel="noopener">AEAD (Authenticated Encryption with Associated Data</a>)。在 AEAD 这种概念里，<code>cipher + MAC</code> 的模式被一个 AEAD 算法替换。</p><p>使用了 AEAD 算法的新协议本质上就是更完善的 <code>stream cipher + authentication</code>，虽然它依然使用的是流加密，但是通过更完善的<strong>数据包完整性验证</strong>机制杜绝了上面所述的可被篡改密文的可能性。</p><blockquote><p>注：截至本文发布时新协议都是使用的 <code>流加密 + 认证</code>，不过 AEAD 的设计使得它能够使用块加密，因此上面说的并不是绝对的。</p></blockquote><p>而为了实现认证加密（Authenticated Encryption），新协议必须要将 TCP 流分割成不同的 chunk 并分别验证。如对新协议的数据包定义有兴趣可以查阅 <a href="https://shadowsocks.org/en/spec/AEAD.html" target="_blank" rel="noopener">官方文档 - AEAD</a>，本文不再深入。</p><h3 id="新协议支持的-AEAD-算法"><a href="#新协议支持的-AEAD-算法" class="headerlink" title="新协议支持的 AEAD 算法"></a>新协议支持的 AEAD 算法</h3><p>目前 shadowsocks-libev <a href="https://github.com/shadowsocks/shadowsocks-libev/releases/tag/v3.0.0" target="_blank" rel="noopener">已经支持</a> 如下的 AEAD 算法，其他分支也正在跟进中：</p><ul><li><p>AES-128-GCM</p></li><li><p>AES-192-GCM</p></li><li><p>AES-256-GCM</p></li><li><p>ChaCha20-IETF-Poly1305</p></li><li><p>XChaCha20-IETF-Poly1305</p></li></ul><p>这些新的加密算法本质上就是 <code>流加密 + 验证</code>，原先的其他单纯的流加密算法均不适用于新协议。</p><h3 id="新协议的优缺点"><a href="#新协议的优缺点" class="headerlink" title="新协议的优缺点"></a>新协议的优缺点</h3><p>使用了 AEAD 算法的新协议能够解决上面描述的 Original/OTA 协议的所有问题，可以有效防范 CCA 和中间人攻击，减少被主动探测的风险。我能想到的唯一的缺点大概就是性能了，但是它又能影响多少呢？Benchmark 参考在 <a href="https://github.com/shadowsocks/shadowsocks-libev/issues/1173" target="_blank" rel="noopener">这里</a>。</p><p>shadowsocks 原本就不是为「加速网络」而生的项目，它的初衷是「突破网络审查并提供安全的加密访问」。是继续使用很可能会被 GFW 封锁的原协议呢，还是选择使用更安全的新协议呢，相信各位看官心中自有定夺。</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>写这篇文章之前我对密码学的了解也就是一点皮毛程度而已，所以这篇文章也是我边查资料边写出来的。为了不让自己误人子弟，我非常谨慎查阅了相关资料并向他人请教（衷心感谢 @breakwa11 和 @madeye 对本文的审阅和提出的建议！）</p><p>但是所谓「金无足赤，人无完人」，如果文章中仍有什么错误的地方，欢迎在下方评论区批评指正。</p><blockquote><p>大家都不容易，谨以此文敦促 shadowsocks 用户 / 开发者们尽快使用 / 支持新协议。</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://github.com/shadowsocks/shadowsocks-org/issues/30" target="_blank" rel="noopener">SIP004 - Support for AEADs implemented by large libraries</a></p></li><li><p><a href="https://shadowsocks.org/en/spec/one-time-auth.html" target="_blank" rel="noopener">Shadowsocks - One Time Auth</a></p></li><li><p><a href="https://github.com/breakwa11/shadowsocks-rss/issues/38" target="_blank" rel="noopener">ShadowSocks 协议的弱点分析和改进</a></p></li><li><p><a href="https://breakwa11.blogspot.com/2016/09/shadowsocks.html" target="_blank" rel="noopener">Shadowsocks 各分支的安全性</a></p></li><li><p><a href="https://github.com/shadowsocks/shadowsocks-org/issues/36" target="_blank" rel="noopener">Deprecate stream ciphers with insufficient IV length</a></p></li><li><p><a href="https://www.kancloud.cn/digest/modern-crypto/79572" target="_blank" rel="noopener">现代密码学实践指南 - 名词解释</a></p></li><li><p><a href="https://zh.wikipedia.org/zh-cn/%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">分组密码工作模式</a></p></li><li><p><a href="http://crypto.stackexchange.com/questions/6008/streaming-api-to-authenticated-encryption" target="_blank" rel="noopener">Streaming API to authenticated encryption</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天，shadowsocks 提出了 SIP004 草案，旨在使用 &lt;code&gt;AEAD 算法&lt;/code&gt; 取代原先的不安全的 &lt;code&gt;流加密 + OTA&lt;/code&gt;，并弃用了一次性验证 (OTA)。&lt;/p&gt;
&lt;p&gt;新协议的提出对于 shadowsocks 是一个非常非常重大的改进，因此我写了这篇博文为看不懂洋文的朋友们科普一下「为什么 OTA 会被这么快被弃用」以及「为什么应该使用新协议」。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>V2Ray 教程</title>
    <link href="http://yoursite.com/2017/09/19/v2ray/"/>
    <id>http://yoursite.com/2017/09/19/v2ray/</id>
    <published>2017-09-19T10:33:41.000Z</published>
    <updated>2018-03-18T12:37:29.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="V2Ray-安装"><a href="#V2Ray-安装" class="headerlink" title="V2Ray 安装"></a>V2Ray 安装</h2><p>V2Ray 提供了一个在 Linux 中的自动化安装脚本。这个脚本会自动检测有没有安装过 V2Ray，如果没有，则进行完整的安装和配置；如果之前安装过 V2Ray，则只更新 V2Ray 二进制程序而不更新配置。</p><p>以下指令假设已在 su 环境下，如果不是，请先运行 <code>sudo su</code>。</p><p>运行下面的指令下载并安装 V2Ray。当 yum 或 apt-get 可用的情况下，此脚本会自动安装 unzip 和 daemon。这两个组件是安装 V2Ray 的必要组件。如果你使用的系统不支持 yum 或 apt-get，请自行安装 unzip 和 daemon。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><a id="more"></a><p>此脚本会自动安装以下文件：</p><ul><li><code>/usr/bin/v2ray/v2ray</code>：V2Ray 程序</li><li><code>/etc/v2ray/config.json</code>：配置文件</li></ul><p>此脚本会配置自动运行脚本。自动运行脚本会在系统重启之后，自动运行 V2Ray。目前自动运行脚本只支持带有 Systemd 的系统，以及 Debian / Ubuntu 全系列。</p><p>运行脚本位于系统的以下位置：</p><ul><li><code>/lib/systemd/system/v2ray.service</code>：Systemd</li><li><code>/etc/init.d/v2ray</code>：SysV</li></ul><p>脚本运行完成后，你需要：</p><ol><li>编辑 <code>/etc/v2ray/config.json</code> 文件来配置你需要的代理方式；</li><li>运行 <code>service v2ray start</code> 来启动 V2Ray 进程；</li><li>之后可以使用 <code>service v2ray start|stop|status|reload|restart|force-reload</code> 控制 V2Ray 的运行。</li></ol><h2 id="V2Ray-配置"><a href="#V2Ray-配置" class="headerlink" title="V2Ray 配置"></a>V2Ray 配置</h2><p>V2Ray 共有三种传输方式，可以形成三种使用方案。</p><h3 id="TCP-模式（支持-TLS）"><a href="#TCP-模式（支持-TLS）" class="headerlink" title="TCP 模式（支持 TLS）"></a>TCP 模式（支持 TLS）</h3><p>使用TCP来传输，这种方式和其它代理应用模式上差不多。TCP 模式可以使用 HTTP/TLS 混淆来模拟 HTTP 网站流量，但也只是模拟，并不是真实的 HTTP 流量。</p><p>header 项是关于数据包伪装的设置，可自定义合理的内容，但要确保服务器与客户端一致</p><h4 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"log"</span> : &#123;</span><br><span class="line">    <span class="attr">"access"</span>: <span class="string">"/var/log/v2ray/access.log"</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"/var/log/v2ray/error.log"</span>,</span><br><span class="line">    <span class="attr">"loglevel"</span>: <span class="string">"warning"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"inbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"clients"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span>,</span><br><span class="line">          <span class="attr">"level"</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">      <span class="attr">"network"</span>: <span class="string">"tcp"</span>,</span><br><span class="line">      <span class="attr">"tcpSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"header"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"http"</span>,</span><br><span class="line">          <span class="attr">"response"</span>: &#123;</span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"1.1"</span>,</span><br><span class="line">            <span class="attr">"status"</span>: <span class="string">"200"</span>,</span><br><span class="line">            <span class="attr">"reason"</span>: <span class="string">"OK"</span>,</span><br><span class="line">            <span class="attr">"headers"</span>: &#123;</span><br><span class="line">              <span class="attr">"Content-Type"</span>: [<span class="string">"application/octet-stream"</span>, <span class="string">"application/x-msdownload"</span>, <span class="string">"text/html"</span>, <span class="string">"application/x-shockwave-flash"</span>],</span><br><span class="line">              <span class="attr">"Transfer-Encoding"</span>: [<span class="string">"chunked"</span>],</span><br><span class="line">              <span class="attr">"Connection"</span>: [<span class="string">"keep-alive"</span>],</span><br><span class="line">              <span class="attr">"Pragma"</span>: <span class="string">"no-cache"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outboundDetour"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"blackhole"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"blocked"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"routing"</span>: &#123;</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="string">"rules"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"rules"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"ip"</span>: [</span><br><span class="line">            <span class="string">"0.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"10.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"100.64.0.0/10"</span>,</span><br><span class="line">            <span class="string">"127.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"169.254.0.0/16"</span>,</span><br><span class="line">            <span class="string">"172.16.0.0/12"</span>,</span><br><span class="line">            <span class="string">"192.0.0.0/24"</span>,</span><br><span class="line">            <span class="string">"192.0.2.0/24"</span>,</span><br><span class="line">            <span class="string">"192.168.0.0/16"</span>,</span><br><span class="line">            <span class="string">"198.18.0.0/15"</span>,</span><br><span class="line">            <span class="string">"198.51.100.0/24"</span>,</span><br><span class="line">            <span class="string">"203.0.113.0/24"</span>,</span><br><span class="line">            <span class="string">"::1/128"</span>,</span><br><span class="line">            <span class="string">"fc00::/7"</span>,</span><br><span class="line">            <span class="string">"fe80::/10"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"blocked"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"log"</span>: &#123;</span><br><span class="line">    <span class="attr">"loglevel"</span>: <span class="string">"warning"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"inbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"socks"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"auth"</span>: <span class="string">"noauth"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"vnext"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"address"</span>: <span class="string">"serveraddr.com"</span>,</span><br><span class="line">          <span class="attr">"port"</span>: <span class="number">443</span>,</span><br><span class="line">          <span class="attr">"users"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span>,</span><br><span class="line">              <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"streamSettings"</span>: &#123;</span><br><span class="line">      <span class="attr">"network"</span>: <span class="string">"tcp"</span>,</span><br><span class="line">      <span class="attr">"tcpSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"header"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"http"</span>,</span><br><span class="line">          <span class="attr">"request"</span>: &#123;</span><br><span class="line">            <span class="attr">"version"</span>: <span class="string">"1.1"</span>,</span><br><span class="line">            <span class="attr">"method"</span>: <span class="string">"GET"</span>,</span><br><span class="line">            <span class="attr">"path"</span>: [<span class="string">"/"</span>],</span><br><span class="line">            <span class="attr">"headers"</span>: &#123;</span><br><span class="line">              <span class="attr">"Host"</span>: [<span class="string">"itunes.apple.com"</span>],</span><br><span class="line">              <span class="attr">"User-Agent"</span>: [</span><br><span class="line">                <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75 Safari/537.36"</span>,</span><br><span class="line">                        <span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 10_0_2 like Mac OS X) AppleWebKit/601.1 (KHTML, like Gecko) CriOS/53.0.2785.109 Mobile/14A456 Safari/601.1.46"</span></span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">"Accept-Encoding"</span>: [<span class="string">"gzip, deflate"</span>],</span><br><span class="line">              <span class="attr">"Connection"</span>: [<span class="string">"keep-alive"</span>],</span><br><span class="line">              <span class="attr">"Pragma"</span>: <span class="string">"no-cache"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outboundDetour"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">      <span class="attr">"settings"</span>: &#123;&#125;,</span><br><span class="line">      <span class="attr">"tag"</span>: <span class="string">"direct"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"routing"</span>: &#123;</span><br><span class="line">    <span class="attr">"strategy"</span>: <span class="string">"rules"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"domainStrategy"</span>: <span class="string">"IPIfNonMatch"</span>,</span><br><span class="line">      <span class="attr">"rules"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"field"</span>,</span><br><span class="line">          <span class="attr">"ip"</span>: [</span><br><span class="line">            <span class="string">"0.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"10.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"100.64.0.0/10"</span>,</span><br><span class="line">            <span class="string">"127.0.0.0/8"</span>,</span><br><span class="line">            <span class="string">"169.254.0.0/16"</span>,</span><br><span class="line">            <span class="string">"172.16.0.0/12"</span>,</span><br><span class="line">            <span class="string">"192.0.0.0/24"</span>,</span><br><span class="line">            <span class="string">"192.0.2.0/24"</span>,</span><br><span class="line">            <span class="string">"192.168.0.0/16"</span>,</span><br><span class="line">            <span class="string">"198.18.0.0/15"</span>,</span><br><span class="line">            <span class="string">"198.51.100.0/24"</span>,</span><br><span class="line">            <span class="string">"203.0.113.0/24"</span>,</span><br><span class="line">            <span class="string">"::1/128"</span>,</span><br><span class="line">            <span class="string">"fc00::/7"</span>,</span><br><span class="line">            <span class="string">"fe80::/10"</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"chinasites"</span>,</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"chinaip"</span>,</span><br><span class="line">          <span class="attr">"outboundTag"</span>: <span class="string">"direct"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WebSocket-模式-（支持-TLS）"><a href="#WebSocket-模式-（支持-TLS）" class="headerlink" title="WebSocket 模式 （支持 TLS）"></a>WebSocket 模式 （支持 TLS）</h3><p>WebSocket 是一种在 HTTP 之上的协议，本质也是TCP传输，但是是天然的 HTTP 网站流量。并且可以搭配各种 HTTP 服务器（比如 Nginx, Caddy）一起使用。</p><p>因为 WebSocket 已经是 HTTP 的一种，所以并不需要任何伪装（混淆）。</p><p>这里主要需要一个 Nginx 作为反代，比较熟悉的人直接 <code>apt-get/yum</code> 安装 Nginx 就好，可以跳过这一步。但是 LNMP 作为解决方案对小白来说比较友好。</p><p>LNMP 1.4 版 代码来源 <a href="https://lnmp.org/" target="_blank" rel="noopener">https://lnmp.org/</a> 。</p><p>由于 LNMP 安装时间很长，所以我们先运行一下 <code>screen</code>。这样如果发生中断，可以重新连接 VPS 用 <code>screen -r</code> 来恢复之前的安装而不至于被中断。</p><p>安装代码 <code>wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp</code>。</p><p><img src="/images/LNMP.png" alt></p><p>建一个虚拟机 <code>lnmp vhost add</code>。</p><p>根据自己需求配置，推荐选项只适合本文开启 V2Ray 的 WS 模式。</p><ul><li><p>输入 VPS 绑定的域名，以 <a href="http://www.serveraddr.com" target="_blank" rel="noopener">www.serveraddr.com</a> 为例；</p></li><li><p>没有其他的域名直接回车，也可以加个无 www 版本 serveraddr.com；</p></li><li><p>默认目录，直接回车;</p></li><li><p>重写规则，选 n；</p></li><li><p>是否开启 log，选 n；</p></li><li><p>是否创建数据库，选 n；</p></li><li><p>是否添加 SSL，推荐选 y，选择 2 使用 Let’s Encrypt 自动签发证书；</p></li><li><p>输入自己邮箱</p></li></ul><p><img src="/images/vhost-add.png" alt></p><p>任意键开始建立网站虚拟机。虚拟机建好后，我们需要修改 Nginx 的配置。LNMP 安装的 Nginx 配置文件位于 <code>/usr/local/nginx/conf/vhost</code> 目录下，文件名为 <code>www.serveraddr.com.conf</code>。</p><p>打开这个文件 <code>vi /usr/local/nginx/conf/vhost/www.serveraddr.com.conf</code>，在 server 443 端口中添加一段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /v2ray/ &#123;</span><br><span class="line">proxy_redirect off;</span><br><span class="line">proxy_pass http://127.0.0.1:10000;</span><br><span class="line">proxy_http_version 1.1;</span><br><span class="line">proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">proxy_set_header Host $http_host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将网站目录 /v2ray/ 目录的数据全部转发到本地 10000 端口，之后配置的 V2Ray 需要监听这个端口。保存退出后，重启 Nginx：<code>service nginx restart</code>。</p><p><img src="/images/Nginx.png" alt></p><h4 id="服务器配置-1"><a href="#服务器配置-1" class="headerlink" title="服务器配置"></a>服务器配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"inbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">10000</span>,</span><br><span class="line">    <span class="attr">"listen"</span>:<span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"clients"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span>,</span><br><span class="line">          <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"streamSettings"</span>:&#123;</span><br><span class="line">      <span class="attr">"network"</span>:<span class="string">"ws"</span></span><br><span class="line">      <span class="string">"wsSettings"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"/v2ray/"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端配置-1"><a href="#客户端配置-1" class="headerlink" title="客户端配置"></a>客户端配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"inbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"socks"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"auth"</span>: <span class="string">"noauth"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"vnext"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"address"</span>: <span class="string">"serveraddr.com"</span>,</span><br><span class="line">          <span class="attr">"port"</span>: <span class="number">443</span>,</span><br><span class="line">          <span class="attr">"users"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span>,</span><br><span class="line">              <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"streamSettings"</span>:&#123;</span><br><span class="line">      <span class="attr">"network"</span>:<span class="string">"ws"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mKCP-模式"><a href="#mKCP-模式" class="headerlink" title="mKCP 模式"></a>mKCP 模式</h3><p>使用 UDP 来传输，mKCP是以流量换速度，就是多倍发包，同一份数据发多份，防止丢包重传，所以同一条件下使用mKCP会比其他方式耗费更多流量，不建议手机4G使用。</p><p>由于BT下载、游戏、以及视频聊天等也都是使用 UDP 传输，所以这种模式下可以伪装成 BT下载流量、FaceTime 流量、微信视频流量。</p><p>由于 BBR 是 TCP 加速技术，所以使用 mKCP 并不能享受 BBR 的加速，不过 mKCP 本身就是一种加速技术了，也并不需要 BBR。</p><h4 id="服务器配置-2"><a href="#服务器配置-2" class="headerlink" title="服务器配置"></a>服务器配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"inbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">443</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"clients"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span>,</span><br><span class="line">          <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"streamSettings"</span>:&#123;</span><br><span class="line">      <span class="attr">"network"</span>:<span class="string">"kcp"</span>,</span><br><span class="line">      <span class="attr">"kcpSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"mtu"</span>: <span class="number">1350</span>,</span><br><span class="line">        <span class="attr">"tti"</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">"uplinkCapacity"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"downlinkCapacity"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"congestion"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"readBufferSize"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"writeBufferSize"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"header"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"none"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"freedom"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端配置-2"><a href="#客户端配置-2" class="headerlink" title="客户端配置"></a>客户端配置</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"inbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"socks"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"auth"</span>: <span class="string">"noauth"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"outbound"</span>: &#123;</span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"vmess"</span>,</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">      <span class="attr">"vnext"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"address"</span>: <span class="string">"serveraddr.com"</span>,</span><br><span class="line">          <span class="attr">"port"</span>: <span class="number">443</span>,</span><br><span class="line">          <span class="attr">"users"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="attr">"id"</span>: <span class="string">"b831381d-6324-4d53-ad4f-8cda48b30811"</span>,</span><br><span class="line">              <span class="attr">"alterId"</span>: <span class="number">64</span></span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"streamSettings"</span>:&#123;</span><br><span class="line">      <span class="attr">"network"</span>:<span class="string">"kcp"</span>,</span><br><span class="line">      <span class="attr">"kcpSettings"</span>: &#123;</span><br><span class="line">        <span class="attr">"mtu"</span>: <span class="number">1350</span>,</span><br><span class="line">        <span class="attr">"tti"</span>: <span class="number">20</span>,</span><br><span class="line">        <span class="attr">"uplinkCapacity"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"downlinkCapacity"</span>: <span class="number">100</span>,</span><br><span class="line">        <span class="attr">"congestion"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"readBufferSize"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"writeBufferSize"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"header"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"none"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的配置当中，与之前相比主要的变化在于多了一个 streamSettings，包含有不少参数：</p><ul><li><code>network</code>: 网络的选择，要像上面的配置写成 kcp 才会启用 mKCP</li><li><code>kcpSettings</code>: 包含一些关于 mKCP 设置的参数，有<ul><li><code>uplinkCapacity</code>: 上行链路容量，将决定 V2Ray 向外发送数据包的速率。单位为 MB</li><li><code>downlinkCapacity</code>：下行链路容量，将决定 V2Ray 接收数据包的速率。单位同样是 MB</li><li><code>header</code>：对于数据包的伪装<ul><li><code>type</code>：要伪装成的数据包类型</li></ul></li></ul></li></ul><p>客户端的上行对于服务器来说是下行，同样地客户端的下行是服务器的上行，mKCP 设置当中服务器和客户端都有 uplinkCapacity 和 downlinkCapacity，所以客户端的上传速率由服务器的 downlinkCapacity 和客户端的 uplinkCapacity 中的最小值决定，客户端的下载速率也是同样的道理。因此，建议将服务器和客户端的 downlinkCapacity 设成一个很大的值，然后分别修改两端的 uplinkCapacity 以调整上下行速率。</p><p>还有一个 header 参数可以对 mKCP 进行伪装，这是 mKCP 的一个优势。具体的伪装在 type 参数设置，type 可以设置成 utp、srtp、wechat-video 或者 none，这四个可以分别将 mKCP 数据伪装成 BT 下载、视频通话、微信视频通话以及不进行伪装。这里的 type 参数，客户端与服务器要一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;V2Ray-安装&quot;&gt;&lt;a href=&quot;#V2Ray-安装&quot; class=&quot;headerlink&quot; title=&quot;V2Ray 安装&quot;&gt;&lt;/a&gt;V2Ray 安装&lt;/h2&gt;&lt;p&gt;V2Ray 提供了一个在 Linux 中的自动化安装脚本。这个脚本会自动检测有没有安装过 V2Ray，如果没有，则进行完整的安装和配置；如果之前安装过 V2Ray，则只更新 V2Ray 二进制程序而不更新配置。&lt;/p&gt;
&lt;p&gt;以下指令假设已在 su 环境下，如果不是，请先运行 &lt;code&gt;sudo su&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;运行下面的指令下载并安装 V2Ray。当 yum 或 apt-get 可用的情况下，此脚本会自动安装 unzip 和 daemon。这两个组件是安装 V2Ray 的必要组件。如果你使用的系统不支持 yum 或 apt-get，请自行安装 unzip 和 daemon。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bash &amp;lt;(curl -L -s https://install.direct/go.sh)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Surge 原理与实现</title>
    <link href="http://yoursite.com/2017/09/14/surge/"/>
    <id>http://yoursite.com/2017/09/14/surge/</id>
    <published>2017-09-14T11:23:27.000Z</published>
    <updated>2017-09-14T12:11:12.989Z</updated>
    
    <content type="html"><![CDATA[<p>Surge 是基于 iOS 9 的新特性 Network Extension 开发的一款网络调试工具，工作原理是使用 Packet Tunnel Provider 给系统套上一个代理，Surge 有两个主要组件：Surge 代理服务器和 Surge TUN 接口。程序运行之后，Surge 会将自身设置为默认的 HTTP/HTTPS 代理服务器来处理所有的 HTTP/HTTPS 流量。针对一些不服从系统代理设置（如 Mail.app ）的应用程序 ，将由 Surge 的 TUN 接口来进行处理。</p><a id="more"></a><p>Surge 会接管全局的（几乎）所有通信，所以所有网络方面的电量消耗都会被算在 Surge 头上，实际上 Surge 的运行功耗很少，使用中也不会感到 Surge 对电量有明显影响。</p><p><img src="/images/surge.png" alt></p><h2 id="Surge-Proxy-Server"><a href="#Surge-Proxy-Server" class="headerlink" title="Surge Proxy Server"></a>Surge Proxy Server</h2><p>这是 Surge 最核心的部分，用于处理所有的 HTTP / HTTPS 请求。用 Proxy 去处理请求而不是用 TUN，有很多原因，主要是因为 TUN 是工作在 IP Layer 的：</p><ul><li><p>Proxy 可以直接收到包含域名 / URL 的请求，从而使基于域名的规则过滤成为可能（甚至 URL，之后版本可能考虑加入支持）</p></li><li><p>Proxy 可以省略不必要的 DNS 请求，对首次访问的速度提升相当明显</p></li><li><p>Surge 的 Proxy 支持全局的 HTTP Connection Keep Alive 机制，极大的减少了 TCP 握手产生的开销（跨应用间也能共享一个 TCP Connection，但由于内存限制在 iOS 版本上超时时间很短，之后 Mac 版本上的效果会明显一些）</p></li><li><p>准确的记录下每个请求的 header 和 body（从 TCP 层面直接抓，可能会有误）</p></li><li><p>使得之后的高级功能（如修改 header，rewrite URL）成为可能</p></li><li><p>减少了不必要的 IP Packet 相关开销</p></li><li><p>这样 Surge iOS 版本与 Mac 版本可以共享核心代码</p></li></ul><p>这是 Surge 中最复杂的组件，基本上等同于一个不带 cache 的 squid，其中的难点一方面是调度问题，另一方面是怎么样去判断一个 HTTP 请求是否完成(比如 chunked transfer encoding)，本身 HTTP RFC 在这方面就有非常多的细节问题，再加上很多自制的 HTTP Server 不是特别的遵守规范，所以只能通过大量的时间去积累经验完成。</p><h2 id="DNS-Client"><a href="#DNS-Client" class="headerlink" title="DNS Client"></a>DNS Client</h2><ul><li><p>可以完全自定义 upstream DNS 服务器地址，无视系统设置</p></li><li><p>可以并发的向多个 DNS 服务器发出 question</p></li><li><p>可以自定义超时和重发的策略</p></li><li><p>getaddrinfo 等方法本身不支持 cache</p></li><li><p>为之后的 Local DNS Map 功能提供了基础</p></li></ul><h2 id="Surge-TUN-Interface"><a href="#Surge-TUN-Interface" class="headerlink" title="Surge TUN Interface"></a>Surge TUN Interface</h2><p>部分应用使用的是 HTTP/HTTPS 以外的 TCP 协议 （如 SPDY、IMAP），没有遵从代理设置，因此无法被 Surge 接管流量。为了解决这个问题，才加入了这个组件。</p><p>核心原理就是通过一个 Surge 内部的 TCP stack，将 IP Packet 中的 TCP 数据提取出来，再重新用 Proxy 进行请求（或者直接连接对应的服务器），再将返回的数据重新封装成 IP Packet。</p><p>正如前面提到的，用 TUN 处理请求会有一些问题，最大的问题是，由 TUN Interface 处理的流量，DOMAIN 相关的 Rule 会无效，除非使用了 force-remote-dns 选项。</p><p>这是由 TCP/IP 协议的特性所决定的，App 会先发出一个 DNS question，获取要连接的服务器的 IP 地址，然后直接向这个 IP 地址发起连接，所以有了第 4 个组件。</p><h2 id="IP-Layer-DNS-Forwarder"><a href="#IP-Layer-DNS-Forwarder" class="headerlink" title="IP Layer DNS Forwarder"></a>IP Layer DNS Forwarder</h2><p>这个组件配合 TUN Interface 使用，会将收到 DNS 的 IP Packet，进行简单改动后直接转发给 upstream DNS。</p><p>但是在转发前，该组件会检查需要解析的域名，是否匹配上了带有 force-remote-dns 选项的规则，如果是，不进行转发，直接返回一个 240.1.x.x 的 fake IP。当 TUN Interface 收到一个发往 240.1.x.x 的包的时候，反向查出真正的域名是什么，然后直接以域名的形式转交给 Proxy，避免本地的 DNS 查询动作。</p><p>force-remote-dns 选项主要是为了解决有些域名在本地查询会有障碍的问题（如公司内网域名），然而因为返回了一个 fake IP，且 Surge 没有权限去强制清除系统或者应用的 DNS cache，所以在 Surge 关闭后可能导致一些问题，所以请谨慎地只给确实需要的域名开启这个选项。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Surge 是基于 iOS 9 的新特性 Network Extension 开发的一款网络调试工具，工作原理是使用 Packet Tunnel Provider 给系统套上一个代理，Surge 有两个主要组件：Surge 代理服务器和 Surge TUN 接口。程序运行之后，Surge 会将自身设置为默认的 HTTP/HTTPS 代理服务器来处理所有的 HTTP/HTTPS 流量。针对一些不服从系统代理设置（如 Mail.app ）的应用程序 ，将由 Surge 的 TUN 接口来进行处理。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>屏蔽 VPS 25 端口</title>
    <link href="http://yoursite.com/2017/09/12/block-port-25/"/>
    <id>http://yoursite.com/2017/09/12/block-port-25/</id>
    <published>2017-09-12T10:06:51.000Z</published>
    <updated>2017-10-30T12:01:32.802Z</updated>
    
    <content type="html"><![CDATA[<p>VPS 在频繁访问 25 端口的时候会被服务商判定为发送垃圾邮件，导致 VPS 被暂停。</p><p>运行以下命令，添加防火墙规则，屏蔽 25 端口</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iptables -A INPUT -s x.x.x.x/xx -j ACCEPT</span><br><span class="line">iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -A INPUT -i lo -j ACCEPT</span><br><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -A OUTPUT -p tcp --dport 25 -j DROP</span><br><span class="line">iptables -A OUTPUT -p udp --dport 25 -j DROP</span><br></pre></td></tr></table></figure><p>保存规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables-save &gt; /etc/iptables.up.rules</span><br></pre></td></tr></table></figure><p>编辑 <code>/etc/network/interfaces</code>，在最后添加以下内容，开机加载屏蔽规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-up iptables-restore &lt; /etc/iptables.up.rules</span><br></pre></td></tr></table></figure><p>编辑 <code>/etc/rsyslog.conf</code>，输出日志到 iptables.log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kern.warning /var/log/iptables.log</span><br></pre></td></tr></table></figure><p>在 iptables 中添加日志选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A OUTPUT -p tcp --dport 25 -j LOG --log-prefix &quot;iptables&quot;</span><br></pre></td></tr></table></figure><p>重启日志服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service rsyslog restart</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;VPS 在频繁访问 25 端口的时候会被服务商判定为发送垃圾邮件，导致 VPS 被暂停。&lt;/p&gt;
&lt;p&gt;运行以下命令，添加防火墙规则，屏蔽 25 端口&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SSH 无密码登录及 putty 设置</title>
    <link href="http://yoursite.com/2017/09/12/authentication/"/>
    <id>http://yoursite.com/2017/09/12/authentication/</id>
    <published>2017-09-11T21:14:01.000Z</published>
    <updated>2017-09-12T08:42:23.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="生成公钥和私钥"><a href="#生成公钥和私钥" class="headerlink" title="生成公钥和私钥"></a>生成公钥和私钥</h3><p>Linux 系统中绝大部分的发行版都是用 OpenSSH，所以生成公钥私钥的时候最好用 <code>ssh-keygen</code> 命令，如果用 putty 自带的 PUTTYGEN.EXE 生成会不兼容 OpenSSH，从而会导致登录时出现 <code>server refused our key</code> 错误。</p><p>用 root 登录后运行命令如下。</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):    <span class="comment">##直接回车默认路径</span></span><br><span class="line">Created directory <span class="string">'/root/.ssh'</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):                 <span class="comment">##输入密码短语（留空则直接回车）</span></span><br><span class="line">Enter same passphrase again:                                <span class="comment">##重复密码短语</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">04:e1:93:92:95:ba:55:21:58:05:7d:57:58:92:32:d3 root@vpn</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">|     oB*o. ..=o  |</span></span><br><span class="line"><span class="string">|    .+.+o = E.   |</span></span><br><span class="line"><span class="string">|    o.+... =     |</span></span><br><span class="line"><span class="string">|    ...o         |</span></span><br><span class="line"><span class="string">|     o  S        |</span></span><br><span class="line"><span class="string">|    .            |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">|                 |</span></span><br><span class="line"><span class="string">+-----------------+</span></span><br></pre></td></tr></table></figure><p>在 <code>/root/.ssh/</code> 目录下生成了2个文件，<code>id_rsa</code> 为私钥，<code>id_rsa.pub</code> 为公钥。私钥自己下载到本地电脑妥善保存，公钥则可以任意公开。</p><h3 id="导入公钥"><a href="#导入公钥" class="headerlink" title="导入公钥"></a>导入公钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /root/.ssh/id_rsa.pub &gt;&gt;  /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h3 id="更改-SSH-配置文件"><a href="#更改-SSH-配置文件" class="headerlink" title="更改 SSH 配置文件"></a>更改 SSH 配置文件</h3><p>修改 SSH 的配置文件 <code>/etc/ssh/sshd_config</code>，找到下面3行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#RSAAuthentication yes</span></span><br><span class="line"><span class="comment">#PubkeyAuthentication yes</span></span><br><span class="line"><span class="comment">#AuthorizedKeysFile.ssh/authorized_keys</span></span><br></pre></td></tr></table></figure><p>将前面的 # 去掉后保存。找到下面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication yes</span><br></pre></td></tr></table></figure><p>修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure><p>重启 SSH 服务，运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><h3 id="制作用于-putty-的私钥"><a href="#制作用于-putty-的私钥" class="headerlink" title="制作用于 putty 的私钥"></a>制作用于 putty 的私钥</h3><p>使用 WinScp 等工具将 VPS 上的 <code>/root/.ssh/id_rsa</code> 下载到本地，利用 PUTTYGEN.EXE 转换为 putty 用的 ppk 文件。</p><p><img src="/images/keygen_1.png" alt></p><p>点击 File，Load private key，导入 <code>/root/.ssh/id_rsa</code> 文件。成功后的图片如下所示：</p><p><img src="/images/keygen_2.png" alt></p><p>点击 Save private key 按钮，生成一个后缀为 ppk 的文件。这个文件就是已经制作好的用于 putty 无密码登录的密钥了，妥善保存。</p><p>至此，就只能用私钥登录到 VPS 了，安全性大大增强。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;生成公钥和私钥&quot;&gt;&lt;a href=&quot;#生成公钥和私钥&quot; class=&quot;headerlink&quot; title=&quot;生成公钥和私钥&quot;&gt;&lt;/a&gt;生成公钥和私钥&lt;/h3&gt;&lt;p&gt;Linux 系统中绝大部分的发行版都是用 OpenSSH，所以生成公钥私钥的时候最好用 &lt;code&gt;ssh-keygen&lt;/code&gt; 命令，如果用 putty 自带的 PUTTYGEN.EXE 生成会不兼容 OpenSSH，从而会导致登录时出现 &lt;code&gt;server refused our key&lt;/code&gt; 错误。&lt;/p&gt;
&lt;p&gt;用 root 登录后运行命令如下。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一键安装最新内核并开启 BBR 脚本</title>
    <link href="http://yoursite.com/2017/09/12/bbr/"/>
    <id>http://yoursite.com/2017/09/12/bbr/</id>
    <published>2017-09-11T20:55:47.000Z</published>
    <updated>2019-08-27T09:17:59.027Z</updated>
    
    <content type="html"><![CDATA[<p>最近，Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，最新的 4.11 版内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。<br>根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。</p><a id="more"></a><blockquote><p>本脚本适用环境</p></blockquote><p>系统支持：CentOS 6+，Debian 7+，Ubuntu 12+<br>虚拟技术：OpenVZ 以外的，比如 KVM、Xen、VMware 等<br>内存要求：≥128M<br>日期　　：2018 年 12 月 14 日</p><h3 id="关于本脚本"><a href="#关于本脚本" class="headerlink" title="关于本脚本"></a>关于本脚本</h3><p>1、当脚本检测到 VPS 的虚拟方式为 OpenVZ 时，会提示错误，并自动退出安装。<br>2、脚本运行完重启发现开不了机的，打开 VPS 后台控制面板的 VNC, 开机卡在 grub 引导, 手动选择内核即可。<br>3、由于是使用最新版系统内核，最好请勿在生产环境安装，以免产生不可预测之后果。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用 root 用户登录，运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -s -L https://git.io/BBR)</span><br></pre></td></tr></table></figure><p>安装完成后，脚本会提示需要重启 VPS，输入 <code>y</code> 并回车后重启。<br>重启完成后，进入 VPS，验证一下是否成功安装最新内核并开启 TCP BBR，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>查看内核版本，含有 <code>4.12</code> 就表示 OK 了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_available_congestion_control</span><br></pre></td></tr></table></figure><p>返回值一般为：<br><code>net.ipv4.tcp_available_congestion_control = bbr cubic reno</code><br>或者为：<br><code>net.ipv4.tcp_available_congestion_control = reno cubic bbr</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.tcp_congestion_control</span><br></pre></td></tr></table></figure><p>返回值一般为：<br><code>net.ipv4.tcp_congestion_control = bbr</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.core.default_qdisc</span><br></pre></td></tr></table></figure><p>返回值一般为：<br><code>net.core.default_qdisc = fq</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure><p>返回值有 <code>tcp_bbr</code> 模块即说明bbr已启动。注意：并不是所有的 VPS 都会有此返回值，若没有也属正常。</p><h3 id="CentOS-下最新版内核-headers-安装方法"><a href="#CentOS-下最新版内核-headers-安装方法" class="headerlink" title="CentOS 下最新版内核 headers 安装方法"></a>CentOS 下最新版内核 headers 安装方法</h3><p>本来打算在脚本里直接安装 kernel-ml-headers，但会出现和原版内核 headers 冲突的问题。因此在这里添加一个脚本执行完后，手动安装最新版内核 headers 之教程。<br>执行以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel -y install kernel-ml-headers</span><br></pre></td></tr></table></figure><p>根据 CentOS 版本的不同，此时一般会出现类似于以下的错误提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: kernel-ml-headers conflicts with kernel-headers-2.6.32-696.20.1.el6.x86_64</span><br><span class="line">Error: kernel-ml-headers conflicts with kernel-headers-3.10.0-693.17.1.el7.x86_64</span><br></pre></td></tr></table></figure><p>因此需要先卸载原版内核 headers ，然后再安装最新版内核 headers。执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove kernel-headers</span><br></pre></td></tr></table></figure><p>确认无误后，输入 y，回车开始卸载。注意，有时候这么操作还会卸载一些对内核 headers 依赖的安装包，比如 gcc、gcc-c++ 之类的。不过不要紧，我们可以在安装完最新版内核 headers 后再重新安装回来即可。<br>卸载完成后，再次执行上面给出的安装命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=elrepo-kernel -y install kernel-ml-headers</span><br></pre></td></tr></table></figure><p>成功安装后，再把那些之前对内核 headers 依赖的安装包，比如 gcc、gcc-c++ 之类的再安装一次即可。</p><p>为什么要安装最新版内核 headers 呢？<br>这是因为 shadowsocks-libev 版有个 tcp fast open 功能，如果不安装的话，这个功能是无法开启的。</p><h3 id="内核升级方法"><a href="#内核升级方法" class="headerlink" title="内核升级方法"></a>内核升级方法</h3><p>如果是 CentOS 系统，执行如下命令即可升级内核：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install kernel-ml kernel-ml-devel</span><br></pre></td></tr></table></figure><p>如果你还手动安装了新版内核 headers ，那么还需要以下命令来升级 headers ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install kernel-ml-headers</span><br></pre></td></tr></table></figure><p>CentOS 6 的话，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">'s/^default=.*/default=0/g'</span> /boot/grub/grub.conf</span><br></pre></td></tr></table></figure><p>CentOS 7 的话，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-set-default 0</span><br></pre></td></tr></table></figure><p>如果是 Debian / Ubuntu 系统，则需要手动下载最新版内核来安装升级。<br>去<a href="http://kernel.ubuntu.com/~kernel-ppa/mainline/" title="这里" target="_blank" rel="noopener">这里</a>下载最新版的内核 deb 安装包。<br>如果系统是 64 位，则下载 amd64 的 linux-image 中含有 <code>generic</code> 这个 deb 包；<br>如果系统是 32 位，则下载 i386 的 linux-image 中含有 <code>generic</code> 这个 deb 包；<br>安装的命令如下（以最新版的 64 位 4.12.4 举例而已，请替换为下载好的 deb 包）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -i linux-image-4.12.4-041204-generic_4.12.4-041204.201707271932_amd64.deb</span><br></pre></td></tr></table></figure><p>安装完成后，再执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/update-grub</span><br></pre></td></tr></table></figure><p>最后，重启 VPS 即可。</p><h3 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h3><p>如果你使用的是 Google Cloud Platform（GCP）更换内核，有时会遇到重启后，整个磁盘变为只读的情况。只需执行以下命令即可恢复：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount rw /</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近，Google 开源了其 TCP BBR 拥塞控制算法，并提交到了 Linux 内核，最新的 4.11 版内核已经用上了该算法。根据以往的传统，Google 总是先在自家的生产环境上线运用后，才会将代码开源，此次也不例外。&lt;br&gt;根据实地测试，在部署了最新版内核并开启了 TCP BBR 的机器上，网速甚至可以提升好几个数量级。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>翻墙小结</title>
    <link href="http://yoursite.com/2017/09/11/breakwall/"/>
    <id>http://yoursite.com/2017/09/11/breakwall/</id>
    <published>2017-09-11T15:11:02.000Z</published>
    <updated>2017-09-28T15:37:49.692Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着我国相关法律条款的日益完善，本自乱象丛生的 <a href="https://en.m.wikipedia.org/wiki/Virtual_private_network" target="_blank" rel="noopener">VPN</a> 市场如今已渐渐被控制，使用传统协议 （<a href="https://en.m.wikipedia.org/wiki/Internet_Key_Exchange" target="_blank" rel="noopener">IKE</a>、<a href="https://en.m.wikipedia.org/wiki/IPsec" target="_blank" rel="noopener">IPSec</a>、<a href="https://en.m.wikipedia.org/wiki/Point-to-Point_Tunneling_Protocol" target="_blank" rel="noopener">PPTP</a> …） 的科学上网方式也变得更加困难；加上第三方服务商的不透明性，不稳定性，使得第三方科学上网的安全性 （如 <a href="https://en.m.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener">MITM</a> …），速度体验让人堪忧…</p></blockquote><a id="more"></a><p><strong>故本文将详细介绍如何创造一个安全快速的个人科学上网服务环境；涉及服务端的选择，搭建、优化、安全性加强和客户端的选择，以达到更好的科学上网体验；适合有一定知识的 Linux 用户和善于使用搜索引擎的小白阅读…</strong></p><p><em>（仅供参考，请在法律范围内使用该教程，如有违反法律规定，作者概不负责）</em></p><h2 id="VPS-服务商的选择"><a href="#VPS-服务商的选择" class="headerlink" title="VPS 服务商的选择"></a>VPS 服务商的选择</h2><p><a href="https://en.m.wikipedia.org/wiki/Virtual_private_server" target="_blank" rel="noopener">VPS</a> 服务商的选择将直接影响你的科学上网体验，下面提供一些参考建议，提供商均安全可靠且有一定知名度；<strong>在获得一个 VPS 实例之前，你可能需要先注册好相关账号并准备一张具有国际支付功能的信用卡 （Visa、MasterCard …）</strong></p><ul><li><p><strong><a href="https://cloud.google.com/" target="_blank" rel="noopener">Google Cloud Computing Engine</a> （推荐）</strong><br>需要一个 Google 账号，初次注册可以获得300$有效期为一年的使用卷，最低配置使用一年几乎免费；建议选择 Asia 机房 （IP Location：Mountain View），速度和稳定性极佳，但不支持 IPv6 （不使用负载均衡的情况下）</p></li><li><p><strong><a href="https://aws.amazon.com/" target="_blank" rel="noopener">AWS EC2</a></strong><br>需要一个 Amazon 账号，初次注册可以获得一年的 Free Trial 权限，出入站流量各 15GB/月；建议选择 Tokyo 机房 （IP Location：Tokyo），稳定性极佳，速度尚可，支持 IPv6 （需<strong><a href="http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpc-migrate-ipv6.html" target="_blank" rel="noopener">设置 VPC</a></strong>）</p></li><li><p><strong><a href="https://vultr.com/" target="_blank" rel="noopener">Vultr</a></strong><br>账号注册简易（可以使用 <a href="https://www.paypal.com/" target="_blank" rel="noopener">PayPal</a> 付款，无需信用卡），初次注册仅送 50GB Block Storage，但费用廉价；建议选择5$套餐，包括 1TB Bandwidth/月，建议选择 Tokyo 机房 （IP Location:：Tokyo），速度一般，稳定性尚可，支持 IPv6</p></li><li><p><strong><a href="https://linode.com/" target="_blank" rel="noopener">Linode</a></strong><br>账号注册简易，初次注册无优惠，费用廉价，建议选择5$套餐，包括 1TB Bandwidth/月，建议选择 Tokyo 机房 （IP Location：Tokyo），速度极佳，稳定性一般 （由于曾经某些人的滥用，导致 IP 极易被 Ban），支持 IPv6</p></li><li><p><strong><a href="https://lightsail.aws.amazon.com/" target="_blank" rel="noopener">Lightsail</a></strong><br>需要一个 Amazon 账号，由 AWS 推出，初次注册无优惠，费用廉价配置一般，建议选择5$套餐，包括 500GB Bandwidth/月，建议选择 Tokyo 机房 （IP Location：Tokyo），速度一般，稳定性极佳，不支持 IPv6</p></li><li><p><strong><a href="https://www.digitalocean.com/" target="_blank" rel="noopener">Digital Ocean</a></strong><br>账号注册简易，初次注册无优惠，费用廉价，建议选择5$套餐，包括 1TB Bandwidth/月，建议选择 Singapore 机房 （IP Location：Singapore），速度一般，稳定性极佳，支持 IPv6</p></li><li><p><strong><a href="https://azure.microsoft.com/en-us/" target="_blank" rel="noopener">Azure</a></strong><br>需要一个 Microsoft 帐户，初次注册可获得300$有效期为三个月的试用卷；长期使用价格昂贵，建议选择 Japan East/West 机房 （IP Location：Japan），速度和稳定性极佳，支持 IPv6</p></li></ul><p><em>*云服务平台的质量随时都在变化，以上仅供参考</em></p><h2 id="科学上网服务端搭建"><a href="#科学上网服务端搭建" class="headerlink" title="科学上网服务端搭建"></a>科学上网服务端搭建</h2><h3 id="搭建-Shadowsocks-libev-服务器"><a href="#搭建-Shadowsocks-libev-服务器" class="headerlink" title="搭建 Shadowsocks-libev 服务器"></a>搭建 Shadowsocks-libev 服务器</h3><p><strong><em>Q1.为什么使用 Shadowsocks 协议？</em></strong></p><blockquote><p>相比传统的 VPN （IKE、IPSec、PPTP …），Shadowsocks 协议具有更好的灵活性和隐蔽性，且搭建相对简单，因此可以拥有相对传统 VPN 更快的速度和更高的稳定性；另对比 <a href="https://www.v2ray.com/" target="_blank" rel="noopener">V2Ray</a> 这种科学上网的集合体，Shadowsocks 在服务端更加轻量，单一协议完善程度更高；在移动端有更丰富的客户端选择，兼容性和灵活性更优。关于 Shadowsocks 的协议特点，原理及弱点的更多讨论，可以在<strong><a href="https://github.com/breakwa11/shadowsocks-rss/issues/38" title="这里" target="_blank" rel="noopener">这里</a></strong>稍做了解，本文不对此长篇大论</p></blockquote><p><strong><em>Q2.为什么使用 <a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">Shadowsock-libev</a> 服务端？</em></strong></p><blockquote><p>相比原版 <a href="https://github.com/shadowsocks/shadowsocks" title="Shadowsocks" target="_blank" rel="noopener">Shadowsocks</a> (Python)，libev (C#) 版本提供了更多的特性支持；而关于<a href="https://github.com/shadowsocksr/shadowsocksr" title="ShadowsocksR" target="_blank" rel="noopener">ShadowsocksR</a> (Python)，Shadowsocks-libev 率先支持 <strong><a href="https://en.m.wikipedia.org/wiki/Authenticated_encryption" title="AEAD" target="_blank" rel="noopener">AEAD</a></strong> 加密，并向 ShadowsocksR 学习引进了 <strong><a href="https://github.com/shadowsocksr/obfsplugin" title="Obfs" target="_blank" rel="noopener">Obfs</a></strong> （<a href="https://github.com/shadowsocks/simple-obfs" title="Simple-Obfs" target="_blank" rel="noopener">Simple-Obfs</a>，但与前者原理有所不同），且提供稳定的周期性更新；关于未来，ShadowsocksR 更倾向于 none 加密策略，而 Shadowsocks-libev 则倾向于传统的加密策略，两者有不同的侧重点 （ShadowsocksR 更侧重消除特征以避免被检测识别，而 Shadowsocks-libev 则追求更高的安全性），综合起来并无优劣之分</p></blockquote><p>*2017年7月28日，ShadowsocksR团队正式解散</p><ol><li><p><strong>以 root 权限运行命令</strong></p><p>初次连接到实例，一般需要获取 root 权限 （非 root 用户的情况下），获取方法如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br><span class="line"><span class="comment"># 运行以上命令，重设 root 用户密码</span></span><br><span class="line">su</span><br><span class="line"><span class="comment"># 运行以上命令，使用重设后的 root 密码登录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>开始搭建 Shadowsocks-libev 服务端</strong></p><p><strong><a href="https://github.com/shadowsocks/shadowsocks-libev#linux" target="_blank" rel="noopener">自行搭建</a></strong></p></li><li><p><strong>自定义 Shadowsocks-libev 服务端*</strong></p><p>在使用默认的配置<strong>安装完毕后</strong>，对安装后的配置文件进行编辑，编辑命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/shadowsocks-libev/config.json</span><br><span class="line"><span class="comment"># 运行以上命令，对其安装后的运行参数进行编辑自定义（语法为 json 标准格式）</span></span><br></pre></td></tr></table></figure><p>参数如下，详见 <strong>[Shadowsocks-libev Wiki]( Shadowsocks-libev Wiki “Shadowsocks-libev Wiki”)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">SSLOCAL=<span class="string">"[\"[::0]\",\"0.0.0.0\"]"</span></span><br><span class="line"><span class="comment"># Shadowsocks 的默认监听地址，默认为任何 IPv6 或 IPv4 地址</span></span><br><span class="line">PORT=<span class="string">"443"</span></span><br><span class="line"><span class="comment"># Shadowsocks 使用的端口，建议使用 443 (HTTPS)</span></span><br><span class="line">LOACL=<span class="string">"127.0.0.1"</span></span><br><span class="line"><span class="comment"># 本地监听地址!</span></span><br><span class="line">LOCALPORT=<span class="string">"1080"</span></span><br><span class="line"><span class="comment"># 本地监听端口!</span></span><br><span class="line">PASSWORD=<span class="string">""</span></span><br><span class="line"><span class="comment"># 加密使用的密码，留空将会自动生成，切忌简单密码</span></span><br><span class="line">DNS=<span class="string">"8.8.8.8"</span></span><br><span class="line"><span class="comment"># 默认使用 Google Public DNS 服务器</span></span><br><span class="line">TIMEOUT=<span class="string">"600"</span></span><br><span class="line"><span class="comment"># 未使用的连接超时自动断开，单位 (s)</span></span><br><span class="line">METHOD=<span class="string">"chacha20-ietf-poly1305"</span></span><br><span class="line"><span class="comment"># 加密方式，详见加密*</span></span><br><span class="line">OBFS=<span class="string">"tls"</span></span><br><span class="line"><span class="comment"># 混淆方式，详见混淆*</span></span><br><span class="line">OBFSHOST=<span class="string">"mzstatic.com"</span></span><br><span class="line"><span class="comment"># 混淆域名，详见混淆*</span></span><br><span class="line">WORKERS=<span class="string">"1024"</span></span><br><span class="line"><span class="comment"># 服务使用的线程数，更高的线程数可以提高加解密速度</span></span><br><span class="line">FWS=<span class="string">"enable"</span></span><br><span class="line"><span class="comment"># 伪装成网站服务器，避免被检测</span></span><br><span class="line">ABB=<span class="string">"enable"</span></span><br><span class="line"><span class="comment"># 利用 fail2ban 自动 Ban 掉向服务器发送恶意数据的 IP</span></span><br><span class="line">BBR=<span class="string">"enable"</span></span><br><span class="line"><span class="comment"># 安装 Google-BBR 加速</span></span><br></pre></td></tr></table></figure><p>完成编辑后需<strong>重启 Shadowsocks-libev 应用配置</strong>，命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/shadowsocks restart</span><br><span class="line"><span class="comment"># 运行以上命令重启通过 Shadowsocks-libev 服务端</span></span><br></pre></td></tr></table></figure><p>*加密，推荐使用 AEAD 加密，以下是四种 AEAD 加密方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">aes-128-gcm</span><br><span class="line">aes-192-gcm</span><br><span class="line">aes-256-gcm</span><br><span class="line">chacha20-ietf-poly1305</span><br></pre></td></tr></table></figure><p>以及几种常用的 OTA 加密方式 （OTA 加密一定程度上可以加快加密速度并降低 CPU 使用率，但较前者安全性更低且有明显缺陷）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rc4-md5</span><br><span class="line">aes-128-cfb</span><br><span class="line">aes-128-ctr</span><br></pre></td></tr></table></figure><p>*混淆方式，主要分为 <code>tls</code>、<code>http</code> 两种，相比 <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol" title="http" target="_blank" rel="noopener">http</a>，<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security" title="tls" target="_blank" rel="noopener">tls</a> 更具优势，但支持 Shadowsocks-libev 的 tls 混淆客户端较少</p><p>*混淆域名，使用混淆时伪装的域名，一般选择大型企业、流量出入较大、CDN 等未被墙的域名作为混淆域名 （如伪装的特定端口下的 IP 或域名来免流），常用的混淆域名有这些</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cloudfront.com</span><br><span class="line">cloudflare.com</span><br><span class="line">itunes.apple.com</span><br><span class="line">www.icloud.com</span><br><span class="line">s.mzstatic.com</span><br><span class="line">ajax.microsoft.com</span><br><span class="line">apps.bdimg.com</span><br></pre></td></tr></table></figure></li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li><p><strong><a href="https://en.wikipedia.org/wiki/TCP_Fast_Open" title="TCP Fast Open" target="_blank" rel="noopener">TCP Fast Open</a></strong></p><p>主要通过第一次 TCP 握手后服务器产生 Cookie 作为后续 TCP 连接的认证信息，客户端通过 TCP 再次连接到服务器时，可以在 SYN 报文携带数据 （<a href="https://tools.ietf.org/html/rfc793" title="RFC793" target="_blank" rel="noopener">RFC793</a>），降低了握手频率，可避免恶意攻击并大幅降低网络延迟 （<a href="http://conferences.sigcomm.org/co-next/2011/papers/1569470463.pdf" title="参考" target="_blank" rel="noopener">参考</a>）。下面介绍如何开启这一功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_fastopen = 3"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="comment"># 运行以上命令，设置 IPv4 下的 TFO 默认为开启状态</span></span><br><span class="line">sysctl -e -p</span><br><span class="line"><span class="comment"># 运行以上命令，应用配置</span></span><br></pre></td></tr></table></figure></li><li><p><strong>改善 <a href="https://en.wikipedia.org/wiki/TCP_congestion_control" title="TCP 拥塞算法" target="_blank" rel="noopener">TCP 拥塞算法</a></strong></p><p>HTTP 协议在传输层使用 TCP 协议，TCP 丢包重传机制算法的不同会大幅影响科学上网速度；更换 TCP 拥塞算法需要使用命令 <code>vim /etc/sysctl.conf</code> 编辑系统配置文件，并定位到 <code>net.ipv4.tcp_congestion_control =</code>  这一行 (若没有请手动添加)，其后接的算法主要有 <code>cubic</code>、<code>hybla</code>、<code>bbr</code> 等，修改完成后使用命令 <code>sysctl -e -p</code> 应用配置；下面是相关算法的简单介绍</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cubic  <span class="comment"># 由 bic 算法衍化而来，适用于低丢包率网络</span></span><br><span class="line">hybla  <span class="comment"># 卫星链路使用的算法，适用于高延迟，高丢包率的网络</span></span><br><span class="line">bbr    <span class="comment"># 由 Google 开源的算法，适用于低延迟，较低丢包率的网络 （需要手动配置*）</span></span><br></pre></td></tr></table></figure><p><strong>*配置 <a href="https://github.com/google/bbr" title="Google BBR" target="_blank" rel="noopener">Google BBR</a></strong></p><p>开始配置 BBR 之前，确保你的<strong>内核版本 &gt; 4.8.x</strong> （使用命令 <code>uname -a</code> 查看），若低于最低版本，请先<strong>更新你的内核 （Ubuntu）</strong>；若要更新内核，请先使用命令 <code>vim updatekernel.sh</code> 新建脚本，将下面的代码复制粘贴到脚本内并保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">KERNELVER=<span class="string">"<span class="variable">$(wget -qO- http://kernel.ubuntu.com/~kernel-ppa/mainline/ | awk -F'\"v' '/v[4-9]./&#123;print $2&#125;' | cut -d/ -f1 | grep -v -  | sort -V | tail -1)</span>"</span></span><br><span class="line"><span class="comment"># 获取最新的 Linux Kernel 版本</span></span><br><span class="line">SYSTYPE=<span class="string">"<span class="variable">$(dpkg --print-architecture)</span>"</span></span><br><span class="line"><span class="comment"># 获取系统平台信息</span></span><br><span class="line">[ <span class="string">"<span class="variable">$SYSTYPE</span>"</span> = <span class="string">"amd64"</span> ] &amp;&amp; KERNEL=<span class="string">"<span class="variable">$(wget -qO- http://kernel.ubuntu.com/~kernel-ppa/mainline/v$&#123;KERNELVER&#125;/ | grep "linux-image" | grep "generic" | awk -F'\"&gt;' '/amd64.deb/&#123;print $2&#125;' | cut -d'&lt;' -f1 | head -1)</span>"</span></span><br><span class="line">[ <span class="string">"<span class="variable">$SYSTYPE</span>"</span> = <span class="string">"i386"</span> ] &amp;&amp; KERNEL=<span class="string">"<span class="variable">$(wget -qO- http://kernel.ubuntu.com/~kernel-ppa/mainline/v$&#123;KERNELVER&#125;/ | grep "linux-image" | grep "generic" | awk -F'\"&gt;' '/i386.deb/&#123;print $2&#125;' | cut -d'&lt;' -f1 | head -1)</span>"</span></span><br><span class="line">[ <span class="string">"<span class="variable">$SYSTYPE</span>"</span> = <span class="string">"armhf"</span> ] &amp;&amp; KERNEL=<span class="string">"<span class="variable">$(wget -qO- http://kernel.ubuntu.com/~kernel-ppa/mainline/v$&#123;KERNELVER&#125;/ | grep "linux-image" | grep "generic" | awk -F'\"&gt;' '/armhf.deb/&#123;print $2&#125;' | cut -d'&lt;' -f1 | head -1)</span>"</span></span><br><span class="line">[ <span class="string">"<span class="variable">$SYSTYPE</span>"</span> = <span class="string">"arm64"</span> ] &amp;&amp; KERNEL=<span class="string">"<span class="variable">$(wget -qO- http://kernel.ubuntu.com/~kernel-ppa/mainline/v$&#123;KERNELVER&#125;/ | grep "linux-image" | grep "generic" | awk -F'\"&gt;' '/arm64.deb/&#123;print $2&#125;' | cut -d'&lt;' -f1 | head -1)</span>"</span></span><br><span class="line">[ <span class="string">"<span class="variable">$SYSTYPE</span>"</span> = <span class="string">"ppc64el"</span> ] &amp;&amp; KERNEL=<span class="string">"<span class="variable">$(wget -qO- http://kernel.ubuntu.com/~kernel-ppa/mainline/v$&#123;KERNELVER&#125;/ | grep "linux-image" | grep "generic" | awk -F'\"&gt;' '/ppc64el.deb/&#123;print $2&#125;' | cut -d'&lt;' -f1 | head -1)</span>"</span></span><br><span class="line">[ <span class="string">"<span class="variable">$SYSTYPE</span>"</span> = <span class="string">"s390x"</span> ] &amp;&amp; KERNEL=<span class="string">"<span class="variable">$(wget -qO- http://kernel.ubuntu.com/~kernel-ppa/mainline/v$&#123;KERNELVER&#125;/ | grep "linux-image" | grep "generic" | awk -F'\"&gt;' '/s390x.deb/&#123;print $2&#125;' | cut -d'&lt;' -f1 | head -1)</span>"</span></span><br><span class="line"><span class="comment"># 获取对应平台 Kernel 包的文件名</span></span><br><span class="line">wget -t 3 -T 30 -nv -O <span class="string">"<span class="variable">$KERNEL</span>"</span> <span class="string">"http://kernel.ubuntu.com/~kernel-ppa/mainline/v<span class="variable">$&#123;KERNELVER&#125;</span>/<span class="variable">$&#123;KERNEL&#125;</span>"</span></span><br><span class="line"><span class="comment"># 下载对应的 Kernel</span></span><br><span class="line">dpkg -i <span class="variable">$KERNEL</span></span><br><span class="line"><span class="comment"># 安装下载好的 Kernel</span></span><br><span class="line">rm -f <span class="variable">$KERNEL</span></span><br><span class="line"><span class="comment"># 清理下载文件</span></span><br><span class="line">update-grub</span><br><span class="line"><span class="comment"># 更新启动菜单</span></span><br></pre></td></tr></table></figure><p>然后使用命令 <code>chmod -x updatekernel.sh &amp;&amp; bash updatekernel.sh</code> 给予脚本运行权限并运行脚本来更新内核</p><p>若无需更新内核，则先将拥塞控制算法填写为 <code>bbr</code>，再添加以下代码保存并使用命令 <code>sysctl -e -p</code> 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.core.default_qdisc = fq</span><br><span class="line"><span class="comment"># 将网络拥塞队列算法设置为性能和延迟最佳的 fq_codel</span></span><br></pre></td></tr></table></figure></li><li><p><strong>内核优化</strong></p><p>使用命令 <code>vim sysctl.conf</code> 编辑并在末尾加入如下代码，对系统进程及内存分配进行优化，保存并使用命令 <code>sysctl -e -p</code> 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max = 1024000</span><br><span class="line"><span class="comment"># 系统所有进程一共可以打开的句柄数 (bytes)</span></span><br><span class="line">kernel.msgmnb = 65536</span><br><span class="line"><span class="comment"># 进程通讯消息队列的最大字节数 (bytes)</span></span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line"><span class="comment"># 进程通讯消息队列单条数据最大的长度 (bytes)</span></span><br><span class="line">kernel.shmmax = 68719476736</span><br><span class="line"><span class="comment"># 内核允许的最大共享内存大小 (bytes)</span></span><br><span class="line">kernel.shmall = 4294967296</span><br><span class="line"><span class="comment"># 任意时间内系统可以使用的共享内存总量 (bytes)</span></span><br></pre></td></tr></table></figure><p>使用命令 <code>vim /etc/security/limits.conf</code> 编辑和写入如下代码，限制用户档案的体积大小，提高系统稳定性，完成后保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*                soft    nofile           512000</span><br><span class="line"><span class="comment"># 用户档案警告体积大小 (bytes)</span></span><br><span class="line">*                hard    nofile          1024000</span><br><span class="line"><span class="comment"># 用户档案最大体积大小 (bytes)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>TCP 的优化</strong></p><p>涉及内核控制，TCP 包大小，TCP 转发，连接超时等优化，代码的简单释义已在其下方注明；使用命令 <code>vim sysctl.conf</code> 编辑并写入如下代码，保存并使用命令 <code>sysctl -e -p</code> 应用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">net.core.rmem_max = 12582912</span><br><span class="line"><span class="comment"># 设置内核接收 Socket 的最大长度 (bytes)</span></span><br><span class="line">net.core.wmem_max = 12582912</span><br><span class="line"><span class="comment"># 设置内核发送 Socket 的最大长度 (bytes)</span></span><br><span class="line">net.ipv4.tcp_rmem = 10240 87380 12582912</span><br><span class="line"><span class="comment"># 设置 TCP Socket 接收长度的最小值，预留值，最大值 (bytes)</span></span><br><span class="line">net.ipv4.tcp_wmem = 10240 87380 12582912</span><br><span class="line"><span class="comment"># 设置 TCP Socket 发送长度的最小值，预留值，最大值 (bytes)</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"><span class="comment"># 开启所有网络设备的 IPv4 流量转发，用于支持 IPv4 的正常访问</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="comment"># 开启 SYN Cookie，用于防范 SYN 队列溢出后可能收到的攻击</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="comment"># 允许将等待中的 Socket 重新用于新的 TCP 连接，提高 TCP 性能</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"><span class="comment"># 禁止将等待中的 Socket 快速回收，提高 TCP 的稳定性</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line"><span class="comment"># 设置客户端断开 Sockets 连接后 TCP 在 FIN 等待状态的实际 (s)，保证性能</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 1200</span><br><span class="line"><span class="comment"># 设置 TCP 发送 keepalive 数据包的频率，影响 TCP 链接保留时间 (s)，保证性能</span></span><br><span class="line">net.ipv4.tcp_mtu_probing = 1</span><br><span class="line"><span class="comment"># 开启 TCP 层的 MTU 主动探测，提高网络速度</span></span><br><span class="line">net.ipv4.conf.all.accept_source_route = 1</span><br><span class="line">net.ipv4.conf.default.accept_source_route = 1</span><br><span class="line"><span class="comment"># 允许接收 IPv4 环境下带有路由信息的数据包，保证安全性</span></span><br><span class="line">net.ipv4.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv4.conf.default.accept_redirects = 0</span><br><span class="line"><span class="comment"># 拒绝接收来自 IPv4 的 ICMP 重定向消息，保证安全性</span></span><br><span class="line">net.ipv4.conf.all.send_redirects = 0</span><br><span class="line">net.ipv4.conf.default.send_redirects = 0</span><br><span class="line">net.ipv4.conf.lo.send_redirects = 0</span><br><span class="line"><span class="comment"># 禁止发送在 IPv4 下的 ICMP 重定向消息，保证安全性</span></span><br><span class="line">net.ipv4.conf.all.rp_filter = 0</span><br><span class="line">net.ipv4.conf.default.rp_filter = 0</span><br><span class="line">net.ipv4.conf.lo.rp_filter = 0</span><br><span class="line"><span class="comment"># 关闭反向路径回溯进行源地址验证 (RFC1812)，提高性能</span></span><br><span class="line">net.ipv4.icmp_echo_ignore_broadcasts = 1</span><br><span class="line"><span class="comment"># 忽略所有 ICMP ECHO 请求的广播，保证安全性</span></span><br><span class="line">net.ipv4.icmp_ignore_bogus_error_responses = 1</span><br><span class="line"><span class="comment"># 忽略违背 RFC1122 标准的伪造广播帧，保证安全性</span></span><br><span class="line">net.ipv6.conf.all.accept_source_route = 1</span><br><span class="line">net.ipv6.conf.default.accept_source_route = 1</span><br><span class="line"><span class="comment"># 允许接收 IPv6 环境下带有路由信息的数据包，保证安全性</span></span><br><span class="line">net.ipv6.conf.all.accept_redirects = 0</span><br><span class="line">net.ipv6.conf.default.accept_redirects = 0</span><br><span class="line"><span class="comment"># 禁止接收来自 IPv6 下的 ICMPv6 重定向消息，保证安全性</span></span><br><span class="line">net.ipv6.conf.all.autoconf = 1</span><br><span class="line"><span class="comment"># 开启自动设定本地连接地址，用于支持 IPv6 地址的正常分配</span></span><br><span class="line">net.ipv6.conf.all.forwarding = 1</span><br><span class="line"><span class="comment"># 开启所有网络设备的 IPv6 流量转发，用于支持 IPv6 的正常访问</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <a href="https://gitlab.com/m2crypto/m2crypto" title="m2crypto" target="_blank" rel="noopener">m2crypto</a> 加速加解密 （Python 服务端）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get install build-essential python3-dev python-dev python-pip libssl-dev swig</span><br><span class="line"><span class="comment"># 运行以上命令，安装支持库</span></span><br><span class="line">pip install m2crypto</span><br><span class="line"><span class="comment"># 运行以上命令，安装 m2crypto</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <a href="https://github.com/shadowsocks/kcptun" title="Kcptun" target="_blank" rel="noopener">Kcptun</a> 加速 （会影响 TCP Fast Open 的正常工作，请自行取舍）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$(dpkg --print-architecture)</span>"</span></span><br><span class="line"><span class="comment"># 运行以上命令，查看 Linux 硬件版本</span></span><br></pre></td></tr></table></figure><p>在<strong><a href="https://github.com/shadowsocks/kcptun" title="这里" target="_blank" rel="noopener">这里</a></strong>获取最新的预编译版本 Kcptun (Go) 下载地址 （注意选择相应的 Linux 系统版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget [获取的下载地址]</span><br><span class="line"><span class="comment"># 运行以上命令，下载预编译版本 Kcptun</span></span><br><span class="line">tar -zxvf [下载后的文件名]</span><br><span class="line"><span class="comment"># 运行以上命令，解压预编译文件</span></span><br><span class="line">./[解压后的文件名] -t <span class="string">"[服务器目标IPv4]:[Kcptun目标端口]"</span> -l <span class="string">":[Kcptun监听端口]"</span></span><br><span class="line"><span class="comment"># 运行以上命令启动 Kcptun，具体配置请参考官方 README*</span></span><br></pre></td></tr></table></figure><p>*<a href="https://github.com/shadowsocks/kcptun/blob/shadowsocks/README.en.md" title="kcptun/README" target="_blank" rel="noopener">kcptun/README</a> 官方文档</p></li></ol><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ol><li><p><strong>Web Server 的伪装 （使用 TCP80 或TCP 443 为端口的 Shadowsocks 服务器效果更佳）</strong></p><p>可以使用 <a href="https://en.m.wikipedia.org/wiki/Apache_HTTP_Server" title="Apache" target="_blank" rel="noopener">Apache</a> 来构建一个网站服务器，用于隐藏 Shadowsocks 服务器的特征，防止 Shadowsocks 服务器被运营商或防火墙的主动探测发现；使用以下命令配置 Apache 服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install apache2</span><br><span class="line"><span class="comment"># 运行以上命令，安装 Apache 服务</span></span><br><span class="line">service apache2 start</span><br><span class="line"><span class="comment"># 运行以上命令，启动 Apache 服务*</span></span><br></pre></td></tr></table></figure><p>*若在 TCP80 端口开放或 Shadowsocks 已经连接的状况下在浏览器中输入服务器的 IP 并访问，出现 <code>It’s works!</code> 即为成功配置 Apache Server ；关于安全性加强，请参考②封禁恶意访问 IP</p><p>*究其根本，使用较新的 AEAD 流加密更加有效，以上方法仅在某种层面具有一定的效果</p></li><li><p><strong>封禁恶意访问 IP</strong></p><p>使用 <a href="https://en.m.wikipedia.org/wiki/Fail2ban" title="fail2ban" target="_blank" rel="noopener">fail2ban</a> 来阻止恶意的 SSH 和 Apache Web Server 攻击者，主要是解决潜在的用户攻击者 （比如那些有权限连接到你的 Shadowsocks 服务器的设备可能会绕开实例的外部防火墙，因此单纯配置 Firewall 并不是完全有用的）；首先使用以下命令安装 fail2ban</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install fail2ban</span><br><span class="line"><span class="comment"># 运行以上命令，安装 fail2ban</span></span><br></pre></td></tr></table></figure><p>使用命令 <code>vim /etc/fail2ban/jail.local</code> 按情况添加以下部分代码并保存来配置 fail2ban 规则，首先是 SSH 规则代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[ssh-iptables]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">filter     = sshd</span><br><span class="line">action   = iptables[name=SSH, port=ssh, protocol=tcp]</span><br><span class="line">logpath = /var/<span class="built_in">log</span>/auth.log</span><br></pre></td></tr></table></figure><p>*若开启了 Apache Web Server 伪装，还须添加如下代码保证 Web Server 的安全</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[apache-tcpwrapper]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">filter     = apache-auth</span><br><span class="line">action   = hostdeny</span><br><span class="line">logpath = /var/<span class="built_in">log</span>/httpd/error_log</span><br><span class="line"></span><br><span class="line"> [apache-badbots]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">filter     = apache-badbots</span><br><span class="line">action   = iptables-multiport[name=BadBots, pory=<span class="string">"http,https"</span>]</span><br><span class="line">logpath = /var/<span class="built_in">log</span>/httpd/access_log</span><br><span class="line"></span><br><span class="line"> [apache-shorewall]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">filter     = apache-noscript</span><br><span class="line">action   = shorewall</span><br><span class="line">logpath = /var/<span class="built_in">log</span>/httpd/error_log</span><br></pre></td></tr></table></figure><p>使用 Shadowsocks 或 ShadowsocksR 自带的 <a href="https://github.com/shadowsocks/shadowsocks/wiki/Ban-Brute-Force-Crackers" title="autoban.py" target="_blank" rel="noopener">autoban.py</a> 来禁止恶意的 Shadowsocks 攻击 （仅限 <a href="https://en.m.wikipedia.org/wiki/Python_(programming_language" target="_blank" rel="noopener">Python</a> 服务端，开始前请确保你拥有 Python 环境）；首先找到你的 Shadowsocks(R) 安装路径，请使用命令 <code>cd</code> 进入目录和 <code>ls</code> 显示目录下文件或其它方式找到其<strong>安装路径</strong>，并按照如下步骤安装 <a href="https://github.com/Supervisor/supervisor" title="Supervisor" target="_blank" rel="noopener">Supervisor</a> （用于运行 Autoban）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install supervisor</span><br><span class="line"><span class="comment"># 安装 Supervisor 任务管理，用于后台运行 autoban.py</span></span><br></pre></td></tr></table></figure><p>使用命令 <code>vim /etc/supervisor/conf.d/autoban.conf</code> 创建 supervisor 配置文件，输入如下代码并保存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[program:autoban]</span><br><span class="line"><span class="built_in">command</span>=python autoban.py &lt; /var/<span class="built_in">log</span>/shadowsocks.log</span><br><span class="line">directory=[Shadowsocks(R) 安装路径]/utils</span><br><span class="line">autorestart=<span class="literal">true</span></span><br><span class="line">user=root</span><br></pre></td></tr></table></figure><p>使用如下命令启动 Supervisor 及 Autoban （关于 Autoban 的更多信息请参考<a href="https://github.com/shadowsocks/shadowsocks/wiki/Ban-Brute-Force-Crackers" title="这里" target="_blank" rel="noopener"><strong>这里</strong></a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service supervisor start</span><br><span class="line"><span class="comment"># 运行以上命令，启动 Supervisor 服务</span></span><br><span class="line">supervisorctl reload</span><br><span class="line"><span class="comment"># 运行以上命令，重加载 Autoban 计划</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="客户端的选择"><a href="#客户端的选择" class="headerlink" title="客户端的选择"></a>客户端的选择</h2><p><strong>以下主要介绍各个平台的 GUI Based 客户端，仅供参考</strong> （Simple-Obfs 为 Shadowsocks-libev 的混淆标准，不支持 Simple-Obfs 并不意味着不支持 ShadowsocksR 的 Obfs-Plugin 混淆标准；此处评价仅从 Shadowsocks-libev 的角度出发，请勿误解）</p><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><ul><li><p><strong><a href="https://github.com/shadowsocks/ShadowsocksX-NG" title="ShadowsocksX-NG" target="_blank" rel="noopener">ShadowsocksX-NG</a></strong><br>免费且功能强大的客户端，支持 AEAD，Kcptun，UDP，不支持任何混淆或 TCP Fast Open，稳定性一般</p></li><li><p><strong><a href="http://nssurge.com/" title="Surge" target="_blank" rel="noopener">Surge</a></strong><br>价格昂贵的网络调试工具，支持 AEAD，TCP Fast Open，同时支持 Simple-Obfs 的 http 混淆 （tls 适配中），稳定性极佳</p></li></ul><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li><p><strong><a href="https://github.com/shadowsocks/shadowsocks-windows" title="Shadowsocks-windows" target="_blank" rel="noopener">Shadowsocks-windows</a></strong><br>免费易用的官方客户端，支持 AEAD，UDP，TCP Fast Open 还在测试中，但不支持 Simple-Obfs，稳定性极佳</p></li><li><p><strong><a href="https://github.com/shadowsocks/shadowsocks-qt5" title="Shadowsocks-qt5" target="_blank" rel="noopener">Shadowsocks-qt5</a></strong><br>免费易用的跨平台客户端，但目前不支持 AEAD，TCP Fast Open 和 Simple-Obfs，稳定性一般</p></li></ul><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul><li><p><strong><a href="https://github.com/shadowsocks/shadowsocks-qt5" title="Shadowsocks-qt5" target="_blank" rel="noopener">Shadowsocks-qt5</a></strong><br>免费易用的跨平台客户端，但目前不支持 AEAD，TCP Fast Open 和 Simple-Obfs，稳定性一般</p></li><li><p><strong><a href="https://github.com/avege/avege" title="Avege" target="_blank" rel="noopener">Avege</a></strong><br>免费易用的跨平台客户端，主要适配 ShadowsocksR (与 Shadowsocks-libev 兼容)，不支持 AEAD，TCP Fast Open 和 Simple-Obfs，稳定性一般</p></li></ul><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><ul><li><p><strong><a href="https://itunes.apple.com/us/app/shadowrocket/id932747118?mt=8&uo=4&at=10lJSw&ct=appcards" title="Shadowrocket" target="_blank" rel="noopener">Shadowrocket</a></strong><br>目前最强大的Shadowsocks (R) 付费客户端之一，支持 AEAD，ObfsPlugin，可自定义规则，稳定性一般</p></li><li><p><strong><a href="https://itunes.apple.com/us/app/potatso-2-ultimate-networking-tool/id1162704202?mt=8&uo=4&at=10lJSw&ct=appcards" title="Potatso 2" target="_blank" rel="noopener">Potatso 2</a></strong><br>方便易用的付费客户端，支持 AEAD，Obfs-Plugin，UDP可自定义规则，稳定性一般</p></li><li><p><strong><a href="https://itunes.apple.com/cn/app/surge-web-developer-tool-proxy/id1040100637?mt=8&uo=4&at=10lJSw&ct=appcards" title="Surge" target="_blank" rel="noopener">Surge</a></strong><br>昂贵的网络调试工具，支持 AEAD，TCP Fast Open，Simple-Obfs，MitM 可自定义规则，稳定性极佳</p></li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><ul><li><strong><a href="https://play.google.com/store/apps/details?id=com.github.shadowsocks&hl=zh_CN&uo=4&ct=appcards" title="Shadowsocks" target="_blank" rel="noopener">Shadowsocks</a></strong><br>免费开源的官方客户端，支持 AEAD，TCP Fast Open，Simple-Obfs，Kcptun，UDP，TCP Fast Open (需要 root 权限)，功能十分全面，但稳定性一般</li></ul><h3 id="OpenWRT"><a href="#OpenWRT" class="headerlink" title="OpenWRT"></a>OpenWRT</h3><ul><li><strong><a href="https://github.com/shadowsocks/openwrt-shadowsocks" title="OpenWRT-Shadowsocks" target="_blank" rel="noopener">OpenWRT-Shadowsocks</a></strong><br>开源的官方客户端，支持 AEAD，TCP Fast Open，Simple-Obfs，UDP；<strong>配合 <a href="https://github.com/shadowsocks/ChinaDNS" title="ChinaDNS" target="_blank" rel="noopener">ChinaDNS</a> 和 <a href="https://github.com/shadowsocks/luci-app-shadowsocks" title="luci-app-shadowsocks" target="_blank" rel="noopener">luci-app-shadowsocks</a> (GUI) 使用 （官方 <a href="https://github.com/shadowsocks/luci-app-shadowsocks/wiki" title="Wiki" target="_blank" rel="noopener">Wiki</a>）</strong>，稳定性一般。其中 ChinaDNS，luci-app-shadowsocks 一般可直接在路由器 <em><em>管理界面&gt;软件 （Software） *</em>中安装，后者依赖两个包 <code>iptables</code>  和  <code>ipset</code>；若有 Shadowsocks-libev 缺失情况，可参照命令安装</em></li></ul><p>*命令安装</p><p>在<strong><a href="https://github.com/shadowsocks/luci-app-shadowsocks" title="这里" target="_blank" rel="noopener">这里</a></strong>获取最新预编译 <code>.ipk</code> 地址，使用 <a href="https://en.wikipedia.org/wiki/Telnet" title="Telnet" target="_blank" rel="noopener">Telnet</a> 或 SSH 连接到你的路由，使用以下命令进行安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">opkg install wget</span><br><span class="line"># 运行以上命令安装 wget 服务，用于下载 .ipk 到路由器</span><br><span class="line">wget [获取的.ipk地址]</span><br><span class="line"># 运行以上命令下载 .ipk 到路由；下载前应注意路由器 CPU 型号，确保选择了正确的 .ipk</span><br><span class="line">dpkg -i [下载后的.ipk路径或名称]</span><br><span class="line"># 运行以上命令安装客户端</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>引用一句 <a href="https://github.com/clowwindy" title="clowwindy" target="_blank" rel="noopener">clowwindy</a> 的话：</p><blockquote><p>往往不需要政府造墙，网民也会自发造墙</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;随着我国相关法律条款的日益完善，本自乱象丛生的 &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Virtual_private_network&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VPN&lt;/a&gt; 市场如今已渐渐被控制，使用传统协议 （&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Internet_Key_Exchange&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IKE&lt;/a&gt;、&lt;a href=&quot;https://en.m.wikipedia.org/wiki/IPsec&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;IPSec&lt;/a&gt;、&lt;a href=&quot;https://en.m.wikipedia.org/wiki/Point-to-Point_Tunneling_Protocol&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PPTP&lt;/a&gt; …） 的科学上网方式也变得更加困难；加上第三方服务商的不透明性，不稳定性，使得第三方科学上网的安全性 （如 &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Man-in-the-middle_attack&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MITM&lt;/a&gt; …），速度体验让人堪忧…&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Shadowrocket（小火箭）使用简单说明</title>
    <link href="http://yoursite.com/2017/09/08/shadowrocket-manual/"/>
    <id>http://yoursite.com/2017/09/08/shadowrocket-manual/</id>
    <published>2017-09-08T13:44:02.000Z</published>
    <updated>2019-06-07T12:44:21.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Shadowrocket 是一款基于规则的代理实用工具。</p><ul><li>高性能和稳定性：功能多样，但只占用最少的系统资源。它将完美地处理所有的流量，让你无忧无虑。</li><li>灵活的规则系统：您可以根据域名，IP CIDR，GEOIP 等设置代理转发规则。Shadowrocket 将自动将请求发送到另一个代理服务器。支持的代理协议多样化。</li><li>HTTPS 解密：HTTPS 流量可以被 MitM 解密。证书生成器将帮助您生成用于调试的 CA 证书，并使证书受系统信任。</li><li>本地 DNS 映射：Shadowrocket 支持本地定制的 DNS 映射。其多功能模块，包括通配符，别名和自定义 DNS 服务器，将能够满足不同的需求。</li><li>HTTP 重写：根据自定义规则将 HTTP / HTTPS 请求重写到另一个 URL，或者简单地阻止请求。</li><li>所有功能都可以在蜂窝网络上工作。</li><li>捕获设备上任何应用程序的所有 HTTP / HTTPS / TCP 流量，并将流量重定向到 HTTP / HTTPS / SOCKS5 代理服务器，遵循高度可配置的规则，即使应用程序不遵循系统代理设置。</li><li>即使在蜂窝网络上也可以覆盖系统 DNS 设置。并通过同时向所有 DNS 服务器发送 DNS 查询来提升性能。</li></ul><a id="more"></a><h2 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h2><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>可通过扫码和首页右上角的 ➕ 来操作。</p><h3 id="节点排序"><a href="#节点排序" class="headerlink" title="节点排序"></a>节点排序</h3><p>可通过长按 ➕ 或者节点列表右上角的”三“来操作（号长按为节点排序）。</p><h3 id="全局路由"><a href="#全局路由" class="headerlink" title="全局路由"></a>全局路由</h3><ul><li>配置（即使用 .conf 文件）</li><li>代理（即 PROXY）</li><li>直连（即 DIRECT）</li><li>场景（根据不同使用场合自动切换相关配置，暂时支持使用不同的 urltest 测速分组和 conf 配置文件）</li></ul><h3 id="场景设置"><a href="#场景设置" class="headerlink" title="场景设置"></a>场景设置</h3><p>场景可选无线局域网、蜂窝数据网络、默认；<br>路由可选配置、代理、直连；<br>类型可选单个节点及分组；<br>配置即为该场景使用的配置文件。</p><p><em>如果路由器挂载了 ss 我如何指定该路由下走直连，而其他路由器下走代理？</em></p><blockquote><p>您可以新建一个场景 SSID 取名为 wifi(该四个单词不区分大小写)，然后进行其他相关设置。SSID 设置为 wifi 意思是通配所有 wifi 的 ssid。然后单独设置挂载了 ss 的路由器的场景，ssid 取名为挂载了 ss 的路由器的名称，选择直连即可。</p></blockquote><h3 id="速度测试"><a href="#速度测试" class="headerlink" title="速度测试"></a>速度测试</h3><p>自动选择最优节点，需要添加分组后使用。例如我有节点 a b c d ,可创建分组将其加进去，一般分组内的节点不超过5个为佳，速度测试分组可以和场景搭配使用，具体去场景设置。速度测试分组也可以和配置搭配使用，和配置搭配使用的时候注意下当前勾选的是哪个分组。</p><h3 id="延迟测试"><a href="#延迟测试" class="headerlink" title="延迟测试"></a>延迟测试</h3><p>通过 TCP / ICMP ping 获取当前的延迟信息，延迟信息仅作为参考，无其他实际意义。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>主要是规则相关文件的配置</p><ul><li>从 iCloud 等位置导入配置文件</li><li>从网址导入配置文件</li><li>从 WiFi 上传</li></ul><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><h3 id="基于域名的规则"><a href="#基于域名的规则" class="headerlink" title="基于域名的规则"></a>基于域名的规则</h3><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMAIN,www.apple.com,Proxy</span><br></pre></td></tr></table></figure><p>如果与请求的域名完全相同，则匹配规则。</p><h4 id="域名后缀"><a href="#域名后缀" class="headerlink" title="域名后缀"></a>域名后缀</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMAIN-SUFFIX,apple.com,Proxy</span><br></pre></td></tr></table></figure><p>如果与请求的域名后缀相同，则规则匹配。例如：’google.com’ 匹配 ‘<a href="http://www.google.com&#39;，&#39;mail.google.com&#39;" target="_blank" rel="noopener">www.google.com&#39;，&#39;mail.google.com&#39;</a> 和 ‘google.com’，但并没有匹配’content-google.com’。</p><h4 id="域名关键字"><a href="#域名关键字" class="headerlink" title="域名关键字"></a>域名关键字</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMAIN-KEYWORD,google,Proxy</span><br></pre></td></tr></table></figure><p>如果请求的域包含关键字，则规则匹配。</p><h4 id="基于域名的规则选项"><a href="#基于域名的规则选项" class="headerlink" title="基于域名的规则选项"></a>基于域名的规则选项</h4><p>force-remote-dns</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DOMAIN,www.apple.com,Proxy,force-remote-dns</span><br><span class="line">DOMAIN-SUFFIX,apple.com,Proxy,force-remote-dns</span><br><span class="line">DOMAIN-KEYWORD,google,Proxy,force-remote-dns</span><br></pre></td></tr></table></figure><h3 id="基于IP的规则"><a href="#基于IP的规则" class="headerlink" title="基于IP的规则"></a>基于IP的规则</h3><h4 id="IP-CIDR"><a href="#IP-CIDR" class="headerlink" title="IP-CIDR"></a>IP-CIDR</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IP-CIDR,192.168.0.0/16,DIRECT</span><br><span class="line">IP-CIDR,10.0.0.0/8,DIRECT</span><br><span class="line">IP-CIDR,172.16.0.0/12,DIRECT</span><br><span class="line">IP-CIDR,127.0.0.1/8,DIRECT</span><br></pre></td></tr></table></figure><p>如果请求的IP地址匹配指定范围，则规则匹配。</p><h4 id="GEOIP"><a href="#GEOIP" class="headerlink" title="GEOIP"></a>GEOIP</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEOIP,US,DIRECT</span><br><span class="line">GEOIP,CN,DIRECT</span><br></pre></td></tr></table></figure><p>如果 GeoIP 测试结果符合指定的国家/地区代码，则规则匹配。</p><h4 id="基于-IP-的规则选项"><a href="#基于-IP-的规则选项" class="headerlink" title="基于 IP 的规则选项"></a>基于 IP 的规则选项</h4><p>no-resolve</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEOIP,US,DIRECT,no-resolve</span><br><span class="line">IP-CIDR,172.16.0.0/12,DIRECT,no-resolve</span><br></pre></td></tr></table></figure><p>当遇到 GEOIP 或 IP-CIDR 规则时，Shadowrocket 会发送 DNS 问题，以检查请求的主机名是否为域名。您可以选择 “no-resolve” 选项来跳过具有域名的请求的此规则。</p><p>注意：如果某些域名无法由本地 DNS 服务器解决，请确保在与该域匹配的规则前面没有基于 IP 的规则。否则由于 DNS 错误，规则测试将失败。您也可以使用 “no-resolve” 来解决问题。</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>用于解密 HTTPS。</p><h3 id="延迟测试方法"><a href="#延迟测试方法" class="headerlink" title="延迟测试方法"></a>延迟测试方法</h3><p>建议选择 TCP</p><h3 id="按需求连接"><a href="#按需求连接" class="headerlink" title="按需求连接"></a>按需求连接</h3><p>建议关闭，因为规则不支持 IP-CIDR，所以 Telegram 在按需连接下无法使用。</p><h3 id="代理共享"><a href="#代理共享" class="headerlink" title="代理共享"></a>代理共享</h3><p>首先开启代理共享，其他 iOS 用户去无线局域网下点击当前所处的同一 wifi 右边的感叹号，最下面 HTTP 代理-手动，填写服务器和端口，例如，Shadowrocket 代理共享处的地址为 192.168.123.36:1082，则服务器填写 192.168.123.36，端口填写 1082 即可，电脑及安卓用户类似。</p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>默认参数即可。</p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>类型默认 Socket 即可，Socket 为作者自己实现，Session 为使用苹果的库实现，参数用默认即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Shadowrocket 是一款基于规则的代理实用工具。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;高性能和稳定性：功能多样，但只占用最少的系统资源。它将完美地处理所有的流量，让你无忧无虑。&lt;/li&gt;
&lt;li&gt;灵活的规则系统：您可以根据域名，IP CIDR，GEOIP 等设置代理转发规则。Shadowrocket 将自动将请求发送到另一个代理服务器。支持的代理协议多样化。&lt;/li&gt;
&lt;li&gt;HTTPS 解密：HTTPS 流量可以被 MitM 解密。证书生成器将帮助您生成用于调试的 CA 证书，并使证书受系统信任。&lt;/li&gt;
&lt;li&gt;本地 DNS 映射：Shadowrocket 支持本地定制的 DNS 映射。其多功能模块，包括通配符，别名和自定义 DNS 服务器，将能够满足不同的需求。&lt;/li&gt;
&lt;li&gt;HTTP 重写：根据自定义规则将 HTTP / HTTPS 请求重写到另一个 URL，或者简单地阻止请求。&lt;/li&gt;
&lt;li&gt;所有功能都可以在蜂窝网络上工作。&lt;/li&gt;
&lt;li&gt;捕获设备上任何应用程序的所有 HTTP / HTTPS / TCP 流量，并将流量重定向到 HTTP / HTTPS / SOCKS5 代理服务器，遵循高度可配置的规则，即使应用程序不遵循系统代理设置。&lt;/li&gt;
&lt;li&gt;即使在蜂窝网络上也可以覆盖系统 DNS 设置。并通过同时向所有 DNS 服务器发送 DNS 查询来提升性能。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ShadowsocksR 服务端安装教程</title>
    <link href="http://yoursite.com/2017/09/08/server-setup/"/>
    <id>http://yoursite.com/2017/09/08/server-setup/</id>
    <published>2017-09-08T13:18:08.000Z</published>
    <updated>2017-09-12T08:49:12.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>不建议使用一键脚本安装，除非你自己能维护其功能，否则安装时若出了问题很难查，而且现在有不少不明来历的一键脚本内嵌后门程序。</p><p>此教程为单用户版，适合个人用户。</p><h2 id="基本库安装"><a href="#基本库安装" class="headerlink" title="基本库安装"></a>基本库安装</h2><a id="more"></a><p>以下命令均以 root 用户执行，或 sudo 方式执行</p><p>centos：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>ubuntu/debian：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure><h2 id="获取源代码"><a href="#获取源代码" class="headerlink" title="获取源代码"></a>获取源代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b manyuser https://github.com/appso/shadowsocksr.git</span><br></pre></td></tr></table></figure><p>执行完毕后此目录会新建一个 <code>shadowsocksr</code> 目录，其中根目录的是多用户版（即数据库版，个人用户请忽略这个），子目录中的是单用户版（即 shadowsocksr/shadowsocks）。</p><p>根目录即 <code>./shadowsocksr</code></p><p>子目录即 <code>./shadowsocksr/shadowsocks</code></p><h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>进入根目录初始化配置（假设根目录在 <code>~/shadowsocksr</code>，如果不是，命令需要适当调整）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/shadowsocksr</span><br><span class="line">bash initcfg.sh</span><br></pre></td></tr></table></figure><p>以下步骤要进入子目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/shadowsocksr/shadowsocks</span><br></pre></td></tr></table></figure><h3 id="快速运行"><a href="#快速运行" class="headerlink" title="快速运行"></a>快速运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python server.py -p 443 -k password -m none -O auth_chain_b -o tls1.2_ticket_auth</span><br><span class="line"><span class="comment">#说明：-p 端口 -k 密码  -m 加密方式 -O 协议插件 -o 混淆插件</span></span><br></pre></td></tr></table></figure><p>如果要后台运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python server.py -p 443 -k password -m none -O auth_chain_b -o tls1.2_ticket_auth -d start</span><br></pre></td></tr></table></figure><p>如果要停止/重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python server.py -d stop/restart</span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/<span class="built_in">log</span>/shadowsocksr.log</span><br></pre></td></tr></table></figure><p>用 <code>-h</code> 查看所有参数</p><h3 id="使用配置文件运行"><a href="#使用配置文件运行" class="headerlink" title="使用配置文件运行"></a>使用配置文件运行</h3><p>如果你的ss目录是 <code>~/shadowsocksr</code>，进入这里<br>修改 <code>user-config.json</code> 中的 <code>server_port</code>，<code>password</code> 等字段，具体可参见：<a href="https://github.com/appso/shadowsocks-rss/wiki/config.json" target="_blank" rel="noopener">https://github.com/appso/shadowsocks-rss/wiki/config.json</a>  </p><p>运行子目录内的 server.py：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python server.py</span><br></pre></td></tr></table></figure><p>如果要在后台运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python server.py -d start</span><br></pre></td></tr></table></figure><p>如果要停止/重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python server.py -d stop/restart</span><br></pre></td></tr></table></figure><p>查看日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/<span class="built_in">log</span>/shadowsocksr.log</span><br></pre></td></tr></table></figure><h3 id="更新源代码"><a href="#更新源代码" class="headerlink" title="更新源代码"></a>更新源代码</h3><p>如果代码有更新可用本命令更新代码</p><p>进入 <code>shadowsocksr</code> 目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> shadowsocksr</span><br></pre></td></tr></table></figure><p>执行  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>成功后重启 ssr 服务  </p><h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><p><a href="https://github.com/appso/shadowsocks-rss/wiki/System-startup-script" target="_blank" rel="noopener">System startup script</a></p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>注：以下客户端中有：windows 客户端和 python 版客户端，ShadowsocksX-NG（macOS 客户端之一）， Android 客户端，Shadowrocket（iOS 客户端之一，iTunes 售价$3美元/￥18人民币）， 可以使用 SSR 特性，其他原版客户端只能以兼容的方式连接 SSR 服务器（SSR 可兼容 SS 客户端）。</p><ul><li><a href="https://github.com/shadowsocksrr/shadowsocksr-csharp" target="_blank" rel="noopener">Windows</a> / <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Shadowsocks-for-OSX-Help" target="_blank" rel="noopener">OS X</a> / <a href="https://github.com/yichengchen/ShadowsocksX-R" target="_blank" rel="noopener">ShadowsocksX-NG</a>  </li><li><a href="https://github.com/shadowsocksrr/shadowsocksr" target="_blank" rel="noopener">Linux python</a> / <a href="https://github.com/librehat/shadowsocks-qt5" target="_blank" rel="noopener">Linux Qt</a></li><li><a href="https://github.com/shadowsocksrr/shadowsocksr-android" target="_blank" rel="noopener">Android</a> / <a href="https://github.com/shadowsocks/shadowsocks-iOS/wiki/Help" target="_blank" rel="noopener">iOS</a> / <a href="https://itunes.apple.com/us/app/shadowrocket/id932747118" target="_blank" rel="noopener">Shadowrocket</a></li><li><a href="https://github.com/shadowsocks/openwrt-shadowsocks" target="_blank" rel="noopener">OpenWRT</a></li></ul><p>OSX 上可使用 GoAgentX 的 SSR 插件。在你本地的 PC 或手机上使用图形客户端。具体使用参见它们的使用说明。</p><p>也可以直接使用 <a href="https://github.com/appso/shadowsocks-rss/wiki/Python-client-setup-Mult-language" target="_blank" rel="noopener">Python</a> 版客户端（命令行）。</p><h2 id="其它加密支持"><a href="#其它加密支持" class="headerlink" title="其它加密支持"></a>其它加密支持</h2><p>安装 <a href="https://github.com/appso/shadowsocks-rss/wiki/libsodium" target="_blank" rel="noopener">libsodium</a> 即可支持 salsa20, chacha20, chacha20-ietf 加密（暂不支持<a href="https://github.com/onelogin/aead" target="_blank" rel="noopener">AEAD</a>）</p><h2 id="其它异常"><a href="#其它异常" class="headerlink" title="其它异常"></a>其它异常</h2><p>如果你的服务端 python 版本在 2.6 以下，那么必须更新 python 到 2.6.x 或 2.7.x 版本  </p><p>其它参见 <a href="https://github.com/appso/shadowsocks-rss/wiki/ulimit" target="_blank" rel="noopener">https://github.com/appso/shadowsocks-rss/wiki/ulimit</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h2&gt;&lt;p&gt;不建议使用一键脚本安装，除非你自己能维护其功能，否则安装时若出了问题很难查，而且现在有不少不明来历的一键脚本内嵌后门程序。&lt;/p&gt;
&lt;p&gt;此教程为单用户版，适合个人用户。&lt;/p&gt;
&lt;h2 id=&quot;基本库安装&quot;&gt;&lt;a href=&quot;#基本库安装&quot; class=&quot;headerlink&quot; title=&quot;基本库安装&quot;&gt;&lt;/a&gt;基本库安装&lt;/h2&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/09/06/hello-world/"/>
    <id>http://yoursite.com/2017/09/06/hello-world/</id>
    <published>2017-09-06T15:41:29.201Z</published>
    <updated>2017-09-16T15:22:49.234Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
